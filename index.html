<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title> NYC Baby Names</title>
	<style>
		body {
			margin:40px;
		}
		
		#content {
			width:100%;
			margin:auto;
		}
		
		svg {
			margin:auto;
		}
		
		#c1b {
			position:absolute;
			top:80px;
			left:0;
	
		}
		
		#c1a {
			position:absolute;
			top:80px;
			left:0;
		}
		.axis path {
			fill: none;
			stroke: #999;
			stroke-dasharray: 2 3;
		}
		
		g, circle {
			transition: transform 1s ease;
		}
		
		circle.tick {
			fill: #f3f3f3;
			stroke: #999;
			stroke-dasharray:2 3;
		}
		
		path.spiral {
			fill:none;
			stroke: white;
			stroke-width: 3px;
		}
		</style>
	</head>
<body>
<div>
	<button class="btn" id="all">All</button>
	<button class="btn" id="ETHCTY">Ethnicity</button>
	<button class="btn" id="GNDR">Gender</button>
	<button class="btn" id="SORT">Sort</button>
</div>
<div id="content"></div>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="node_modules/jquery/dist/jquery.js"></script>
<script src="node_modules/underscore/underscore.js"></script>
<script>
d3.csv("data_full.csv", function(error, data) {
	
	var width = 1200;
	var height = 1200;
	var numAxes = 8;
	var tickAxis = 1;
	var start = 0;
	var end = 2;
	
	var theta = function(r) {
		return -2*Math.PI*r;
	}
	
	var arc = d3.svg.arc()
		.startAngle(0)
		.endAngle(2*Math.PI);
		
	var radius = d3.scale.linear()
		.domain([start, end])
		.range([0, d3.min([width, height])/2 - 20]);
		
	var angle = d3.scale.linear()
		.domain([start, end])
		.range([0, 360])
		
	var xx = width/2;
	var yy = height/2;
	
	var svg = d3.select("#content").append("svg")
		.attr("width", width)
		.attr("height", height)
	.append("g")
		.attr("transform", "translate(" + xx + "," + yy + ")")
		.attr("id", "c1a");
		
	$("#content").css('background-color', 'black');
		
	var pieces = d3.range(start, end+0.001, (end-start) / 1000);
	
	var spiral = d3.svg.line.radial()
		.interpolate("cardinal")
		.angle(theta)
		.radius(radius);
	
			
	var ls = svg.selectAll(".spiral")
		.data([pieces])
	.enter().append("path")
		.attr("class", "spiral")
		.attr("d", spiral);
// 		.attr("transform", function (d) { return "rotate(" + 90 + ")" });
	
	//     var fill = d3.scale.ordinal().range(['#827d92','#827354','#523536','#72856a'])
	var fill = d3.scale.category10();

	
	var svg = d3.select('#content').append("svg")
		.attr("width", width)
		.attr("height", height)
		.attr("id", "c1b");
			
	for (var j = 0; j < data.length; j++) {
	
		if (data[j].RNK > 1) {
			data.splice(j,1);
			j--;
			continue;
		}
		else {		
			// Node radius as a function of its name count.
			data[j].radius = +data[j].CNT / 6;
			
			data[j].all = "ALL";
	   
			// Assigning random positions to allow nodes to fly in at start.
			data[j].x = Math.random() * width;
			data[j].y = Math.random() * height;
		}
	}
	
	var padding = 4;
	var maxRadius = d3.max(_.pluck(data, 'radius'));
	
	var getCenters = function(vname, size) {
		var centers, map;
		
			// uniq - produce a duplicate free version of csv data
			// pluck - extracts a unique list of values for vname argument.
			// map - produce an object arrary with name and value
			centers = _.uniq(_.pluck(data, vname)).map(function (d) {
				return {name: d, value: 1};
			});
		
		map = d3.layout.pack().size(size);
		
		// Giving the map the unique nodes from the vname argument.
		map.nodes({children: centers});
		
		return centers;
	};
	
	var nodes = svg.selectAll("g").data(data);
	
	// hacking
	
	var gs = nodes.enter().append("g");
		
	var gsi = gs.append("g");
	
	var circles = gsi.append("circle")
		.attr("class", "node")
		.attr("r", 2)
		.style("fill", function (d) { return fill(d.ETHCTY);  });
	
	console.log(gs[0][0]);
	
	
	circles.transition().duration(1000)
		.attr("r", function(d) { return d.radius; });
		
		gsi.append("text")
		.attr("dx", "-30")
		.attr("fill", "white")
		.attr("font-size", "9")
		.text(function(d) { return d.NM; });
	var force = d3.layout.force();
	
		// Page loads with ethnicity button selected.
	draw('GNDR');
	
	$(".btn").click(function() {
		switch(this.id) {
			case "all":
			case "GNDR":
			case "ETHCTY":
				draw(this.id);
				break;
			case "SORT":
				sort(gs[0]);
				break;
			default:
				console.log("DEFAULT!");
			}
	});
	
	function draw (varname) {
		var centers = getCenters(varname, [width, height]);
		force.on("tick", tick(centers, varname));
		labels(centers);
		force.start();
	}
	
	function sort(list) {
	
		var spiralLength = ls.node().getTotalLength();
		var spiralPadding = spiralLength / list.length;
		for (var i = 0; i < list.length; i++) {
			var spiralPoint = ls.node().getPointAtLength(i * spiralPadding);
			var g = list[i];
			var gi = g.getElementsByTagName("g")[0];
// 			var text = g.getElementsByTagName("text")[0];
			
			var transform = g.getAttribute("transform");
			var matches = transform.match(/\d*\.\d*/g);
			
			// g element current translation
			var x1 = matches[0];
			var y1 = matches[1];
			
			// target translation position relative to svg (0,0)
			var x2 = xx + spiralPoint.x + 40;
			var y2 = yy + spiralPoint.y - 20;
			
			// calculate the offset from g element's current translation
			var gidx = x2 - x1;
			var gidy = y2 - y1;
			
			// set circle's current translation to (0,0)
//  			c.style.transition = "none";			
//  			c.style.transform = "translate(0px,0px)";
 			gi.style.transition = "all 1s ease";
 			gi.style.transform = "translate(" + gidx + "px," + gidy + "px)";
 			
//  			var tdx = cdx - circle.getAttribute("r");
//  			var tdy = cdy - circle.getAttribute("r");
//  			
//  			text.style.transition = "all 1s ease";
//  			text.style.transform = "translate(" + tdx + "px," + tdy + "px)";
 			
		}
	}
	
	/*
	 * Factory type function that returns a function set up by its parameters.
	 */
	function tick(centers, varname) {
		var foci = {}; // Used for quick look-up
		for (var i = 0; i < centers.length; i++) {
			foci[centers[i].name] = centers[i];
		}
		
		return function(e) {
			for (var i = 0; i < data.length; i++) {
				var o = data[i];
				var f = foci[o[varname]];
				o.y += (f.y - o.y) * e.alpha;
				o.x += (f.x - o.x) * e.alpha;
			}
			
			gs.each(collide(.11))
				.attr("transform", function (d) { return "translate(" + d.x + ", " + d.y + ")"; });
		}
	};
	
	/*
	 * Passing in the centers array to determine where to place labels.
	 */
	function labels (centers) {
		svg.selectAll(".label").remove();
		
		svg.selectAll(".label")
			.data(centers).enter().append("text")
			.attr("class", "label")
			.text(function (d) { return d.name })
			.attr("fill", "white")
			.attr("transform", function (d) {
				return "translate(" + (d.x - ((d.name.length)*3)) + ", " + (d.y - d.r + 20) + ")";
			});
	}
	
	// Resolves collisions between d and all other circles.
	// Source: http://bl.ocks.org/mbostock/1748247
	function collide(alpha) {
		var quadtree = d3.geom.quadtree(data);
		return function(d) {
			var r = d.radius + maxRadius + padding,
				nx1 = d.x - r,
				nx2 = d.x + r,
				ny1 = d.y - r,
				ny2 = d.y + r;
			quadtree.visit(function(quad, x1, y1, x2, y2) {
				if (quad.point && (quad.point !== d)) {
					var x = d.x - quad.point.x,
						y = d.y - quad.point.y,
						l = Math.sqrt(x * x + y * y),
						r = d.radius + quad.point.radius + padding;
					if (l < r) {
						l = (l - r) / l * alpha;
						d.x -= x *= l;
						d.y -= y *= l;
						quad.point.x += x;
						quad.point.y += y;
					}
				}
				
				return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
			});
		}
	}
	
}); // End xml callback.
	
</script>
</body>
</html>