<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title> NYC Baby Names</title>
	<style>
	
		/*
		 * Arun's Styling
		 */
		 
		 #Top20Rank {
		 	display:none;
		 	width:100%;
		 }
		 
		 
		text {
			pointer-events: none;
		}
		.innerNodes_node rect {
			pointer-events: all;
		}
		.innerNodes_node rect.highlight {
			stroke: #315B7E;
			stroke-width: 2px;
		}
		.outerNodes_node circle {
			fill: #fff;
			stroke: steelblue;
			stroke-width: 1.5px;
			pointer-events: all;
		}
		.outerNodes_node circle.highlight {
			stroke: #315B7E;
			stroke-width: 2px;
		}
		.link {
			fill: none;
		}
		
		/*
		 * Sam's Styling
		 */
		 
		#chart {
			display:none;
		}
		
		
		#svg-piechart {
				height: 360px;
				margin: 0 auto;                                              
				position: fixed;
				width: 360px;
				padding-left: 50px;
			}
			label{
				display: inline-block;
				padding-top: 5px;
				padding-bottom: 5px;
				padding-left: 5px;
				padding-right: 8px;
			}
		
		/*
		 * Drew's Styling
		 */
		 
		#bttnDiv {
			width:90%;
			margin:20px auto;
			text-align:center;
			height:50px;
		}
		#sam, #arun, #drew {
			display:inline-block;
			width:80px;
			margin:0 auto;
		}
		
		#drew {
			display:none;
		}
		
		#legend {
			position:absolute;
			top:40px;
			left:40px;
			width:200px;
			z-index:99999;
			border:1px solid black;
			transition: all 500ms linear;
		}
		
		.expCtrl {
		height: 50px;
			transition: height 500ms linear;
		}
		
		.squeeze {
			height: 0;
		}
		
		#spimg {
			width: 60px;
			display:block;
			margin: 20px auto;
		}
		
		#rangeDiv {
			width:80%;
			margin:auto;
			text-align:center;
			height:60px;
		}
		
		#sortDiv {	
			width:80%;
			margin:auto;
			text-align:center;
			height:100px;
		}
		
		
		.fades {
			opacity:1;
			transition:opacity 250ms linear;
		}
		
	
		.plabel {
			width:45%;
			text-align: right;
			padding-right:5%;
			display:inline-block;
		}
	
		
		

	
		.axis text {
			font: 10px sans-serif;
			fill: white;
		}
	
		.axis path,
		.axis line {
			fill: none;
			stroke: white;
			shape-rendering: crispEdges;
		}
	
		.x.axis path {
			display:none;
		}
	
		body {
			margin:40px;
		}
		
		#boxout {
			width:100%;
			height:100%;
		}
		
		#box {
			width:100%;
			height:100%;
			z-index:1000;
		}
		
		#container {
			width:100%;
			float:left;
		}
		
		#content {
			position: absolute;
			top:0px;
			left:0px;
			width:100%;
			height:100%;
		}
		
		#compare {
		position:absolute;
			top:0px;
			right:0;
			width:0%;
			height:100%;
			background-color: black;
			transition: width 500ms ease;
		}
		
		#compTab {
			margin: 10px;
			font-size: 24px;
			color: white;
			border: 1px solid yellow;
			z-index:1000;
			width: 100%;
			height: auto;
		}

		
		td {
			padding: 5px;
			border-bottom: 1px solid black;
		}
		
		td.update {
			color: white;
		}
		
		td.enter {
			color:green;
		}
		
		td.exit, tr.exit td {
			color: red;
		}
		
		td.row-header {
			border-right:1px solid black;
			font-weight: bold;
		}
		
		svg {
			margin:auto;
		}
		
		#gravitySVG {
			position:absolute;
			top:0;
			left:0;
			z-index: 1;
	
		}
		
		#spiralSVG {
			position:absolute;
			top:0;
			left:0;
			z-index: -1;
		}
		
		.axis path {
			fill: none;
			stroke: #999;
			stroke-dasharray: 2 3;
		}
		
		g, circle {
			transition: transform 650ms ease;
		}
		
		circle.tick {
			fill: #f3f3f3;
			stroke: #999;
			stroke-dasharray:2 3;
		}
		
		path.spiral {
			fill:none;
			stroke: black;
			stroke-width: 2px;
			opacity:0;
		}
		</style>
	</head>
<body>
<div id="legend">
	<div class="expCtrl">
		<p class="plabel fades">Group By:</p>
		<select id="groupSelect" class="fades">
			<option value="NONE">None</option>		
			<option value="GNDR">Gender</option>
			<option value="ETHCTY">Ethnicity</option>
		</select>
	</div>
	<div class="expCtrl">
		<p class="plabel fades">Color By:</p>
		<select id="colorSelect" class="fades">
			<option value="0">None</option>		
			<option value="1">Gender</option>
			<option value="2">Ethnicity</option>
		</select>
	</div>
	<div id="rangeDiv" class="expCtrl">
		<p class="fades">Scope:</p>
		<input id="scopeRange" class="fades" value="7.5" type="range" min="1.0" max="15.0" step="1.0">
	</div>
	<div id="sortDiv" class="expCtrl">
		<p class="fades">Sort:</p>
		<img id="spimg" class="fades" src="spiral.png">
	</div>
	<div id="bttnDiv">
		<p>View:</p>
		<button id="drew">Explore</button>
		<button id="sam">Analyze</button>
		<button id="arun">Rank</button>
	</div>
</div>
<div id="chart">
				<div id="userInput">
					<button id="top10Button">Top 10</button>
					<button id="top20Button">Top 20</button>
					<button id="top30Button">Top 30</button>
					<button id="top40Button">Top 40</button>
					<br>
					<br>
					<label style="background-color: #0088BF"><input type="checkbox" id="hispanicCheckBox" >Hispanic</label>
					<label style="background-color: #00A368"><input type="checkbox" id="asianCheckBox" >Asian</label>
					<label style="background-color: #FFD300"><input type="checkbox" id="blackCheckBox" >Black</label>
					<label style="background-color: #C40233"><input type="checkbox" id="whiteCheckBox" >White</label>
				</div>
				<svg id="svg-barchart"></svg>
				<svg id="svg-piechart"></svg>
			</div>
<div id="Top20Rank"></div>
<div id="container">
	<div id="content"></div>
	<div id="compare">
		<div id="chartSpace"></div>
		<svg id="boxout"><g id="box"></g></svg>
	</div>
</div>
<script src="node_modules/gravitybox/gravitybox.js"></script>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="node_modules/jquery/dist/jquery.js"></script>
<script src="node_modules/underscore/underscore.js"></script>
<script>

var FEMALE_COLOR = '#EE8482';
var MALE_COLOR = '#86AFF2';
var ASIAN_COLOR = '#00A368';
var BLACK_COLOR = '#FFD300';
var HISPANIC_COLOR = '#0088BF';
var WHITE_COLOR = '#C40233';
			// Generated by the Exaile Playlist Analyzer plugin.
			// (C) 2014 Dustin Spicuzza <dustin@virtualroadside.com>
			//
			// This work is licensed under the Creative Commons Attribution 4.0
			// International License. To view a copy of this license, visit
			// http://creativecommons.org/licenses/by/4.0/.
			//
			// Inspired by http://www.findtheconversation.com/concept-map/
			// Loosely based on http://bl.ocks.org/mbostock/4063550
			var data =  [[1,["SOPHIA","MADISON","ISABELLA","ESTHER","ETHAN","JAYDEN","JAYDEN","MICHAEL"]],[2,["CHLOE","LONDON","MIA","EMMA","OLIVIA","JAYDEN","AIDEN","JUSTIN","JOSEPH"]],[3,["EMILY","KAYLA","SOPHIA","LEAH","RYAN","ELIJAH","JACOB","JACOB"]],[4,["OLIVIA","CHLOE","ASHLEY","SOPHIA","JUSTIN","JEREMIAH","MATTHEW","DAVID"]],[5,["EMMA","AALIYAH","CAMILA","CHAYA","LUCAS","JOSHUA","ANGEL","BENJAMIN"]],[6,["ISABELLA","MAKAYLA","SOFIA","SARAH","JASON","ETHAN","ETHAN","MOSHE"]],[7,["TIFFANY","NEVAEH","EMILY","RACHEL","AIDEN","JOSIAH","CHRISTOPHER","DANIEL"]],[8,["ASHLEY","GABRIELLE","HAILEY","AVA","KEVIN","ISAIAH","DANIEL","ALEXANDER"]],[9,["FIONA","TAYLOR","LEAH","ISABELLA","ERIC","TYLER","ALEXANDER","MATTHEW"]],[10,["ANGELA","JADA","OLIVIA","SERENITY","MADISON","CHANA","DANIEL","MICHAEL","ANTHONY","JACK"]],[11,["VIVIAN","ABIGAIL","FATOUMATA","BRIANNA","EMMA","VICTORIA","MIRIAM","MUHAMMAD","CHRISTIAN","NOAH","JOSHUA","SAMUEL"]],[12,["MICHELLE","FAITH","MELANIE","CHARLOTTE","ELLA","MATTHEW","AMIR","AIDEN","ABRAHAM","JAMES"]],[13,["JOANNA","SARAH","NYLA","ZOE","KIMBERLY","SOFIA","VINCENT","AYDEN","BRANDON","WILLIAM"]],[14,["MIA","KHLOE","NYLAH","SAVANNAH","SAMANTHA","EMILY","ANDREW","JUSTIN","JONATHAN","KEVIN","SEBASTIAN","JOHN"]],[15,["IVY","AVA","SARAH","GENESIS","JULIA","MIA","IVAN","WILLIAM","DAVID","DAVID","NICHOLAS"]],[16,["GRACE","NICOLE","LAILA","LEAH","ALLISON","RIVKA","AUSTIN","MASON","MICHAEL","HENRY"]],[17,["VICKY","ARIANNA","BRIANNA","JAYLA","NIA","AMY","ALEXANDRA","DYLAN","JACOB","MASON","CHAIM"]],[18,["JASMINE","CHELSEA","GABRIELLA","OLIVIA","SARA","ALEX","DANIEL","GABRIEL","ANTHONY"]],[19,["ANNA","MIA","VICTORIA","VALENTINA","ABIGAIL","AARON","EVAN","CHRISTOPHER","ADRIAN","NOAH","ANDREW"]],[20,["ELAINE","ALYSSA","ANIYAH","BRIELLE","DESTINY","ISABELLA","KAYLEE","GABRIELLA","JONATHAN","JADEN","CHRISTIAN","LIAM"]],[21,["ALICE","CATHERINE","CLAIRE","JENNY","MAYA","NAOMI","ABIGAIL","ELIZABETH","JACOB","MALACHI","JOSE","ADAM","CHARLES"]],[22,["ALYSSA","ANGELINA","IRIS","JESSICA","SELINA","TENZIN","PAIGE","GABRIELA","CHLOE","ALEXANDER","ANTHONY","JOSEPH","LUCAS"]],[23,["ALINA","ELLA","SOPHIE","WINNIE","ZOE","AMAYA","ARIEL","HEAVEN","JASMINE","MARIAM","MYA","PARIS","ARIANNA","MAYA","ANTHONY","MOHAMMAD","NATHANIEL","DYLAN","DYLAN"]],[24,["ABIGAIL","AMY","FATIMA","JULIA","SARA","HAILEY","MORGAN","ANGELINA","GRACE","KYLE","LIAM","LUIS","RYAN"]],[25,["AVA","HANNAH","SABRINA","ZAINAB","EMILY","LAYLA","SOPHIA","NICOLE","ANNA","ALVIN","ANDY","MATTHEW","ANDREW","THOMAS"]],[26,["AMANDA","ANGEL","EVA","JOYCE","KAREN","KELLY","SAMANTHA","STEPHANIE","VICTORIA","ZOEY","BELLA","VICTORIA","MOHAMMED","NATHAN","TRISTAN","XAVIER","LUCAS","RYAN","ETHAN"]],[27,["KATHERINE","KAYLA","NINA","IMANI","MILAN","TRINITY","LESLIE","GITTY","BRIAN","LEO","AMARI","BRANDON","JEREMIAH","MENACHEM"]],[28,["ANNIE","CHRISTINA","IRENE","KAYLEE","NATALIE","SHARON","LAUREN","SAMANTHA","ADRIANA","SCARLETT","ZOE","LILY","ZOE","BENJAMIN","AARON","JONATHAN","JORDAN","JEREMY","YOSEF"]],[29,["AUDREY","ERICA","MADISON","SOFIA","ZAHRA","AUTUMN","SANAA","DANIELA","SAMANTHA","MICHAEL","CAMERON","ELIJAH","LUKE"]],[30,["EILEEN","JENNIFER","JESSIE","KATIE","PHOEBE","RACHEL","XIN","AMINATA","KAYLEE","LONDYN","MAYA","MCKENZIE","AALIYAH","ALYSSA","ELIZABETH","EVELYN","FAIGY","ALAN","EMMANUEL","CARLOS","OLIVER"]],[31,["ALLISON","AYESHA","EVELYN","MARYAM","MILA","SERENA","FATIMA","GABRIELLA","HANNAH","SYDNEY","KAYLA","HANNAH","JAMES","JOSHUA","KINGSLEY","CALEB","JASON","AYDEN","STEVEN","NOAH"]],[32,["BELLA","HAILEY","LEAH","LILLIAN","SYEDA","WENDY","ALIYAH","KIMORA","ANDREA","ARIANA","STELLA","STEVEN","DYLAN","LIAM","NICHOLAS","ELI"]],[33,["ARIANA","ELIZABETH","JOCELYN","LILY","QUEENIE","VANESSA","AMIRAH","ELIZABETH","MARIAMA","CHLOE","KATHERINE","GIANNA","MASON","CHASE","RYAN","AARON","GABRIEL"]],[34,["AMELIA","ANIKA","CHARLOTTE","CINDY","CYNTHIA","JANICE","JOY","KATELYN","TINA","ZARA","KAITLYN","MARIAH","MIKAYLA","SANAI","JENNIFER","MARIA","SOPHIE","AIDAN","DEREK","KYLE","MIGUEL","MAX"]],[35,["ADA","AISHA","ALEXANDRA","AMBER","BRIANNA","ERIN","GIANNA","JANNAT","KHLOE","LAUREN","MELODY","REBECCA","SELENA","YU","AMIYAH","ARIELLE","DANIELLE","HARMONY","PEYTON","SKYLAR","KHLOE","EVA","AYAAN","TYLER","ALEXANDER","BRYAN","JUAN","JULIAN","SHIMON"]],[36,["ALEENA","ALIYAH","ARIA","ARYA","CECILIA","CHRISTY","DIYA","ELENA","ERIKA","ISABEL","JIA","MANDY","MINA","SHIRLEY","AMELIA","ANIYA","KYLIE","SKYLA","TIANA","ALEXA","MALKA","ABDULLAH","SAMUEL","JAYLEN","WILLIAM","CHRISTOPHER","ISAAC"]],[37,["ARIANNA","CHRISTINE","DAISY","ELINA","ESHAL","ISABELLE","KAITLYN","KYLIE","RAINA","STELLA","ALANA","AMBER","JADE","MELANIE","SAMIYAH","AVA","AMELIA","BRANDON","JOEL","KAYDEN","MOHAMED","JOHN","JOSHUA"]],[38,["AIZA","ALEXA","ALISHA","ANGIE","ANNABELLE","BONNIE","HELEN","KATE","LEELA","MAGGIE","MEGAN","RENEE","TANISHA","AMANDA","CHRISTINA","MALIA","SARIAH","TAMIA","SARAH","VALERIE","MALKY","ADAM","DAVID","ANDREW","GABRIEL","JASON","XAVIER","ZACHARY"]],[39,["ANGEL","ASHLEY","AUBREY","JAYDA","JORDYN","NADIA","PRINCESS","SADE","TORI","LAYLA","MADISON","ARJUN","GAVIN","OWEN","RAYMOND","BRYCE","CARTER","JAIDEN","JOSEPH","ZION","JOEL","LEO"]],[40,["AMANI","AMIRA","DAKOTA","EGYPT","EMMA","FANTA","GENESIS","GRACE","HAWA","RILEY","SARAI","SHILOH","SKYE","SUMMER","DIANA","JAYLEEN","MICHELLE","ALEXA","REBECCA","NICHOLAS","RICHARD","JOHN","EVAN","JULIAN"]],[41,["AICHA","AMINA","KALIYAH","MALIYAH","SASHA","SHANIA","ZARIAH","EMELY","JADE","MELISSA","NATALIA","STEPHANIE","AVERY","CAROLINE","JEFFREY","JERRY","LIAM","OSCAR","JAMES","MEKHI","NASIR","SAMUEL","AIDEN"]],[42,["ADDISON","AISSATOU","ALEXIS","ARIA","ARIANA","JANIYA","KENNEDY","KIARA","LEILANI","LYRIC","MICHELLE","NAHLA","SANIYA","SANIYAH","SYMPHONY","TIANNA","ZARIA","GIANNA","MAYA","RAIZY","AYDEN","TENZIN","NATHAN","PRINCE","ISAAC","JADEN","JACKSON","JAKE"]],[43,["ANAYA","BROOKE","CAMILLE","FATOU","JANIYAH","KENDRA","KYLA","NATALIA","REBECCA","TARAJI","ALEXANDRA","EVA","ALICE","ANGELINA","JADEN","JORDAN","STANLEY","WILSON","NICHOLAS","IAN","JORDAN","CHRISTIAN","MORDECHAI"]],[44,["ALICIA","ANGELINA","DYLAN","EDEN","ESSENCE","EVA","JANELLE","KELSEY","NATALIE","SAMARA","SHANIYA","ZARA","JESSICA","JOCELYN","NATALIE","SHAINDY","FELIX","IAN","SAMUEL","EDWIN","MASON","YISROEL"]],[45,["AISHA","CHEYENNE","ERIN","JALIYAH","JULIA","KAI","KAMIYAH","KENYA","MACKENZIE","MARYAM","NANA","RACHEL","SAMIYA","SORAYA","TABITHA","ZAHARA","ZANIYAH","ZURI","VALERIA","LILLIAN","LUCY","AHMED","CHRISTIAN","CHRISTOPHER","DARREN","DEVIN","HENRY","JACK","JOHN","JOSEPH","MICAH","ROBERT","SEAN","ISAIAH","JAMES","JESUS","YEHUDA"]],[46,["CHELSEA","CHAVA","NAOMI","ABDUL","CARSON","DANNY","JACKY","MARCUS","ADAM","KAIDEN","KEVIN","AXEL","JONATHAN","LUCA","NATHAN","SEBASTIAN"]],[47,["VANESSA","KAYLA","NICOLE","ADRIAN","BENSON","LOGAN","NOAH","MAMADOU","WILLIAM","ALEJANDRO","ALEX","GIOVANNI","MARK"]],[48,["JASMINE","KAREN","KELLY","DEVORAH","KATHERINE","ANSON","ARYAN","JOHNNY","THOMAS","EVAN","ELIAS","ROBERT"]],[49,["ANGELICA","RIVKY","CHARLES","FARHAN","IBRAHIM","JAKE","JEREMY","LEON","VICTOR","IBRAHIM","LOGAN","NATHANIEL","AARON","LOGAN"]],[50,["DANNA","DANIELLA","DINA","GIULIANA","CALEB","NATHANIEL","RICKY","SYED","TIMOTHY","TONY","DEVIN","MALIK","MARCUS","SINCERE","DEREK","GEORGE"]],[51,["GISELLE","SAVANNAH","BAILA","NATALIE","AARAV","ARMAAN","BRYAN","EDWIN","JIA","ROHAN","MESSIAH","MOHAMMED","ERIC","ERICK","OWEN"]],[52,["KYLIE","SERENITY","ELEANOR","EVELYN","MADELINE","MARIA","NINA","TOBY","ADITYA","ALLEN","EDISON","JAY","LAWRENCE","MARTIN","MAX","PATRICK","SEAN","SEBASTIAN","SIMON","ANDRE","BRIAN","ELI","KADEN","ZACHARY","BRIAN","VINCENT"]],[53,["GRACE","KAMILA","KIARA","CHANY","JULIANA","PENELOPE","SIENNA","VIOLET","ALI","CALVIN","GABRIEL","HARRISON","ISAAC","JACKSON","MOHAMED","IAN","JACE","EMMANUEL","SHLOMO","TYLER"]],[54,["DESTINY","ELIANA","HINDY","ELIJAH","GEORGE","KAI","NELSON","ZACHARY","ZAIN","AIDAN","ALEXIS","LEONARDO","ARON","EVAN","YAKOV"]],[55,["AMELIA","ANA","JAYLA","LEILANI","MARIAH","ELIANA","JULIET","MOLLY","CONNOR","ELVIS","JULIAN","LUKE","PETER","TERRY","TRAVIS","ADEN","AVERY","BLAKE","JULIAN","KHALIL","KYMANI","OMARI","PRESTON","ZAIRE","DIEGO","AIDAN"]],[56,["ALISON","BRIANA","ELLA","MAKAYLA","NEVAEH","CLAIRE","MICHELLE","ROSE","SYDNEY","CODY","EASON","HAYDEN","ISHAAN","LOUIS","MILES","OLIVER","RAYAN","SHAWN","XAVIER","ZAYAN","ADRIAN","ASHTON","GAVIN","ISAAC","KALEB","SHAWN","CRISTIAN","NICOLAS","PATRICK","YITZCHOK"]],[57,["AMAYA","KAITLYN","HAILEY","ISABEL","LILA","NOA","SABRINA","DOMINIC","KAMARI","TRAVIS","ANDRES","BENJAMIN","JADIEL","ASHER"]],[58,["AMANDA","ANGELIQUE","DAISY","JACQUELINE","JOSELYN","LIZBETH","BEATRICE","BROOKE","CATHERINE","EMILIA","FRANCESCA","GOLDY","JOSEPHINE","ABDOUL","JASIAH","JERMAINE","KENNETH","MAURICE","JOSIAH","SANTIAGO","CONNOR","GAVIN","HUDSON","THEODORE"]],[59,["DELILAH","LAILA","MYA","SARA","SCARLET","BRIANNA","SADIE","YITTY","AMADOU","AMARE","ANTONIO","CHANCE","CHARLES","JALEN","JEREMY","LAMAR","LEVI","MYLES","RICHARD","SEKOU","RANDY","TYLER","VICTOR","JONAH","PETER"]],[60,["DANIELLA","ISABEL","LILIANA","MILA","SCARLETT","VALENTINA","BRYSON","DWAYNE","ELIAS","ERIC","GIOVANNI","JAHMIR","JAYSON","KAI","KAMERON","KING","OMAR","OUSMANE","PATRICK","TIMOTHY","ZYAIRE","NATHAN","SOLOMON"]],[61,["ESMERALDA","ITZEL","KATE","LONDON","ZOEY","FIONA","HARPER","VIVIAN","ABDOULAYE","AUSTIN","BENJAMIN","CARMELO","JAMAL","JAMEL","NEHEMIAH","TROY","EDUARDO","LOGAN","MEIR","SIMON","ZEV"]],[62,["ADRIANNA","CRYSTAL","GUADALUPE","LIA","MIKAYLA","NATHALIE","ADRIANA","LAYLA","LEA","LENA","LILIANA","AMAR'E","CHAD","DARIUS","DARREN","HAYDEN","HUNTER","JAMIR","JARED","JESSE","KEITH","KIYAN","LUCAS","SETH","STEVEN","VICTOR","MATEO","DOV","JUSTIN","MILES","NATHANIEL"]],[63,["AMBER","AUBREY","FAITH","KARLA","LUZ","RACHEL","SABRINA","ALYSSA","ARIANNA","CLARA","JULIANNA","RILEY","RUBY","ADONIS","AHMED","ALI","CAYDEN","IBRAHIMA","ISIAH","JACKSON","JELANI","JUSTICE","LANDON","MALCOLM","MARC","MOUSSA","NICOLAS","SEBASTIAN","TERRENCE","HENRY","YAAKOV"]],[64,["ALICIA","BIANCA","JAZMIN","LUNA","SARAI","TIFFANY","ALEXIS","ANNABELLE","ARIANA","JANE","ALIJAH","ALVIN","ANGEL","BRYAN","CHRIS","CODY","COREY","DERRICK","DEVON","DONOVAN","EDWARD","GEORGE","HASSAN","ISHMAEL","JAHEIM","MAKAI","MARQUIS","MILES","NANA","NIGEL","QUINCY","RICARDO","RODNEY","STEPHEN","TERRELL","CALEB","IVAN","JAIDEN","OLIVER","BRANDON","SHMUEL"]],[65,["IZABELLA","KATELYN","MELODY","ARIELLA","AUDREY","ELLIE","FRAIDY","GEORGIA","GIA","LAUREN","PESSY","TALIA","JORGE","OMAR","SHULEM"]],[66,["ALIYAH","BRITTANY","DAYANA","JAYLENE","JULIA","NAOMI","YARETZI","ELIZA","ISABELLE","MARGARET","NECHAMA","TAYLOR","YIDES","ZISSY","ALAN","ELI","JAVIER","JEAN","RICHARD","EDWARD","TZVI"]],[67,["AILEEN","GIA","JADA","JULIANNA","LAUREN","LILY","RIHANNA","SKYLA","BRACHA","EDEN","ELOISE","MADELEINE","MINDY","ANDY","JACE","DOVID","HARRISON","LEVI"]],[68,["ANGELA","DULCE","JASMIN","JULIET","KAILEY","LEILA","LUCIA","NATHALY","RUBY","BLIMY","GITTEL","JULIETTE","LAILA","LIA","LIBBY","LUCIA","NORA","PEARL","PHOEBE","YEHUDIS","AIDAN","JAYDEN"]],[69,["ALLYSON","ANGIE","KAYLEEN","MILA","ADELE","ALIZA","BELLA","EVE","JENNA","JESSICA","LOLA","ROCHEL","SHIRA","SHOSHANA","VERONICA","JOSUE","ROBERT","AVRAHAM","ELIEZER","MAXWELL","MOHAMED"]],[70,["DANA","ISABELLE","LIANA","XIMENA","LYLA","MAEVE","VIVIENNE","YAEL","ZOEY","ADRIEL","TRISTAN","COLE"]],[71,["ANALIA","ARIEL","BRENDA","ELISA","HANNAH","HAYLEE","KEILY","MIAH","MILEY","NAYELI","SIENNA","ALESSANDRA","ASHLEY","BATSHEVA","BLIMA","DYLAN","JACQUELINE","LIBA","MORGAN","NATALIA","RAIZEL","SHIFRA","SURY","YOCHEVED","ANDERSON","KENNETH","MARCUS","MAX","ELIYAHU","MENDEL","SALVATORE","SEAN"]],[72,["ALEJANDRA","ALICE","ALONDRA","AURORA","AYLIN","BRYANNA","DENISE","ELENA","HEIDY","JAZLYN","JULIANA","JULISSA","LESLY","MADELYN","NYLA","ROSELYN","ADDISON","ADINA","ANASTASIA","BRUCHA","ELENA","GABRIELA","SIMA","VERA","ADAM","ANTONIO","FRANCISCO","ADRIAN","ELIJAH","GIOVANNI","JASON","SAM"]],[73,["ALISSON","ERIKA","ESTRELLA","HEAVEN","HEIDI","JULIETTE","KAYLIE","MADELINE","SELENA","SHIRLEY","ADRIANNA","AVIVA","ESTY","HAZEL","HENNY","LAURA","MACKENZIE","DANNY","DARIEL","HECTOR","MANUEL","RAFAEL","ALEX","JUDAH","VICTOR"]],[74,["ANIYAH","ARIELLA","AYLEEN","EILEEN","ESTHER","FERNANDA","GABRIELLE","HALEY","JAZMINE","LAURA","MELANY","MIKAELA","NADIA","PENELOPE","VIOLET","AMINA","DEVORA","ELLE","KAITLYN","KATE","LIANA","MARIAM","SALMA","SKYLAR","SLOANE","EDWARD","GEORGE","SEAN","ALI","ELLIOT","EZRA","OMAR"]],[75,["AISHA","ALESSANDRA","ANNA","ANNABELLE","APRIL","ASHLY","CINDY","GERALDINE","HAYLEY","HELEN","ISIS","JAYLIN","KRYSTAL","NATALY","SHERLYN","TAYLOR","AHUVA","CECILIA","EMERSON","FAIGA","FRADEL","MARY","MICHAL","SASHA","SAVANNAH","SERENA","SHAINA","SIENA","SUMMER","CESAR","EDGAR","MARCOS","PEDRO","COLIN","DECLAN","JORDAN","SIMCHA","STEVEN"]],[76,["AIMEE","ARELY","ATHENA","BRITNEY","CARMEN","CAROLINE","DANIELLE","ELIANNY","FATIMA","JANELLE","JAYLAH","JOHANNA","KATIE","KAYLIN","KEYLA","LESLEY","LINDSAY","MARIANA","PERLA","RILEY","SAMARA","SKYLAR","SOPHIE","WENDY","ALLISON","AMANDA","AMELIE","BATYA","BREINDY","BROOKLYN","DAHLIA","DANIELLE","ERIN","ETTY","GABRIELLE","GEMMA","HADASSAH","IVY","MADELYN","MALAK","MICHAELA","PEREL","SHAINDEL","SIMONE","ANGELO","FERNANDO","JOHAN","CALEB","MOSES"]],[77,["ALANA","ALYSON","ANAYA","ANGELY","BRIELLE","CAROLINA","CELESTE","CHARLOTTE","CHRISTINA","CLARA","DAMARIS","ELIANNA","IMANI","INGRID","IRENE","JAELYNN","JAMIE","JASLENE","JIMENA","KAELYN","KAILYN","MEGAN","MIRANDA","MIRIAM","NATASHA","NINA","NOEMI","RAQUEL","ROSE","SADIE","STELLA","STEPHANY","TATIANA","TIANA","VIVIANA","YAMILET","ALESSIA","ALISA","ANNABEL","ARIEL","BLAKE","BRIDGET","BRYNN","CHARLIE","CHRISTINA","COLETTE","ELISHEVA","ESTER","GOLDA","ISLA","JASMINE","JOYCE","MATILDA","RYAN","SURI","TESSA","TZIVIA","VANESSA","CHRIS","JAKE","JULIO","OSCAR","ARI","ARIEL","BRIAN","COOPER","JOEL","MATTEO","OSCAR","SHIA"]],[78,["ABBY","ARIANNY","BRIANNY","CASSANDRA","CRISTINA","CYNTHIA","HAZEL","IRIS","ISABELA","JAYDA","JAYLYN","KATELYNN","KAYLEIGH","KYLEE","LEA","LEYLA","MARILYN","MARISOL","NANCY","NATHALIA","PAOLA","REBECCA","ROSA","SARIAH","SASHA","SAVANNA","STACY","VERONICA","BRUCHY","DAISY","DANIELA","DIANA","ELISE","IRIS","KYLIE","LARA","LILLY","LINA","MILENA","PAIGE","PARKER","REESE","RIFKY","ROIZY","WILLA","YACHET","ARIEL","DAMIAN","EMANUEL","JULIUS","THOMAS","ARTHUR","FRANK","HUNTER","KEVIN","LEONARDO","MAXIMILIAN","USHER"]],[79,["ADELINE","BARBARA","CASEY","GENEVIEVE","GRETA","KATHRYN","LEORA","LILAH","MAKAYLA","MELANIE","MIKAYLA","RIFKA","RUCHY","TZIPORA","DEVIN","JARIEL","KAYDEN","PABLO","RICARDO","YADIEL","ANTONIO","IAN","ISRAEL","NICOLAS"]],[80,["ALICIA","ALINA","AMIRA","AMY","AVIGAIL","CAITLIN","CAMERON","ELLIANA","FINLEY","HADASSA","HANNA","JORDYN","KAYLEE","KIRA","PIPER","RUTH","SYLVIA","TAMAR","VALERIE","VERONIKA","BRADLEY","JAYSON","NOEL","RAYMOND","AVROHOM","CAMERON","ERIC","MAXIM","RAFAEL","YECHIEL"]],[81,["ANGELICA","ARIELA","ATARA","AUBREY","AUTUMN","AYLA","BIANCA","CELIA","CHAVY","CORA","DALIA","FRIMET","GIOVANNA","IDY","ILANA","IZABELLA","JULIE","LEILA","LONDON","MIRI","NICOLETTE","QUINN","SHEVY","SIMI","TZIPORAH","TZIPPY","YASMINE","BRAYAN","JOAQUIN","MARIO","AHMED","AUSTIN","PAUL","PHILIP","RICHARD","SHAYA"]],[82,["ABRAHAM","ALLEN","CHASE","DOMINIC","ISRAEL","KELVIN","MARCO","CHASE","EFRAIM","WYATT"]],[83,["AMIR","DANTE","EMILIO","JACK","URIEL","ARYEH","DEAN","HERSHEL","KYLE","MAYER","TIMOTHY","TRISTAN"]],[84,["ARMANI","CHARLES","KENNY","MATIAS","BRENDAN","FELIX","FINN","LOUIS"]],[85,["BYRON","CAMERON","GAVIN","JEFFREY","LANDON","MARK","MATHEW","RUBEN","BEN","LORENZO","YEHOSHUA"]],[86,["DARWIN","DERICK","ERIK","GAEL","JAY","JOHNNY","JUNIOR","MOISES","RILEY","ALAN","BARUCH","DOMINICK","ELIAS","GRAHAM","GRIFFIN","HERSHY","LUKA","MARTIN","RAPHAEL","SHANE","SHOLOM"]],[87,["ASHTON","BRYANT","ELIAN","FRANK","ISMAEL","JARED","LUKE","MIKE","VINCENT","AKIVA","CHARLIE","JASPER","LAZER","LEON","MILO","YOEL"]],[88,["ADONIS","BRAYDEN","CARMELO","DOMINICK","GREGORY","JOHNATHAN","LEANDRO","MARTIN","MARVIN","NELSON","PAUL","TIMOTHY","YAHIR","ZACHARY","AHARON","BRODY","CARTER","FRANCESCO","GRAYSON","LIPA","ROCCO"]],[89,["ALBERTO","ALFREDO","AUSTIN","DAMIEN","DENNIS","GUSTAVO","HUNTER","JONAH","MAXIMUS","PETER","RODRIGO","SHAWN","DEVIN","MOISHE","NAFTALI","NAFTULI","XAVIER"]],[90,["ABEL","ENRIQUE","FRANKLIN","JEFFERSON","JEREMIAS","JIMMY","JULIEN","LORENZO","LOUIS","PRESTON","PRINCE","ROMEO","AHRON","ILAN","MATEO","SHLOME","SHMIEL","YITZCHAK"]],[91,["ADEN","ALBERT","AVERY","CRISTOPHER","EMILIANO","ESTEBAN","FREDDY","GIOVANNY","IKER","KADEN","MAXIMILIANO","SERGIO","TRAVIS","YERIK","ZION","ANGELO","AUGUST","BORUCH","ELIMELECH","GREGORY","HARRY","ISAIAH","LUKAS","MARC","MARCO","PARKER","RAYAN","RYDER","SHEA"]],[92,["ABDIEL","EDDIE","FELIX","GERARDO","JAYCE","JOHANN","LEONEL","MAURICIO","MAXIMO","MELVIN","OWEN","PATRICK","YANDEL","YARIEL","ALBERT","AMIR","BRAYDEN","DOMINIC","GAVRIEL","KAI","PINCHAS","SHLOIME","SPENCER"]],[93,["ARMANDO","CRISTOFER","DERECK","EDISON","EZEKIEL","EZEQUIEL","JAIME","JANUEL","JENCARLOS","JERRY","LEO","LUKAS","ROBERTO","ROGER","ROYCE","WILSON","BINYOMIN","BLAKE","BRYAN","CHESKEL","EITAN","GRANT","HERSH","MARCUS","MAXIMUS","RILEY","YISRAEL","ZALMEN"]],[94,["ALDO","ALLAN","ALVIN","ANDRE","ARTURO","BRYCE","ELVIS","GIOVANI","JANIEL","JEANCARLOS","JESSE","LARRY","MARLON","SHANE","STEPHEN","STEVE","TAYLOR","TOMAS","YAIR","YANIEL","AMROM","BENZION","BRADY","CONOR","FILIP","IVAN","JUDE","KIERAN","LANDON","NICO","PINCHUS","QUINN","REID","SHLOIMY","VINCENZO","YIDA"]],[95,["AVI","BECKETT","DASHIELL","ELLIOTT","JESSE","MICAH","ROMAN","ROWAN","YOUSEF"]],[96,["ALEC","ALLEN","AVRUM","CARMINE","DENNIS","GREYSON","HUGO","KACPER","MAKSIM","MEILECH","MENASHE","MENDY","MORRIS","NOAM","NOLAN","SANTINO","SHALOM","SHNEUR","YASEEN","YECHEZKEL","YIDEL","YOUSSEF"]],[97,["ASHTON","AUGUSTUS","AYDEN","BENNETT","BERISH","BRYCE","CADEN","CALVIN","DEREK","ELLIS","KENNETH","LEV","MOHAMMED","NIKOLAS","NOSSON","REED","SAMIR","SHAUL","SIDNEY","SILAS","STEPHEN","WESLEY","YEHUDAH","YONAH"]]];
			// transform the data into a useful representation
			// 1 is innerNodes, 2, is outerNodes
			// need: innerNodes, outerNodes, links
			//
			// innerNodes:
			// links: { innerNodes: outerNodes: }
			var outerNodes = d3.map();
			var innerNodes = [];
			var links = [];
			var outerNodesId = [0];
			var count=1;
				data.forEach(function (d) {
						//Top 20 Ranks
						if (count <= 20) {
							if (d == null)
								return;
							i = {id: 'i' + innerNodes.length, name: d[0], related_links: []};
							i.related_nodes = [i.id];
							innerNodes.push(i);
							if (!Array.isArray(d[1]))
								d[1] = [d[1]];
							d[1].forEach(function (d1) {
								o = outerNodes.get(d1);
								if (o == null) {
									o = {name: d1, id: 'o' + outerNodesId[0], related_links: []};
									o.related_nodes = [o.id];
									outerNodesId[0] = outerNodesId[0] + 1;
									outerNodes.set(d1, o);
								}
								// create the links
								l = {id: 'l-' + i.id + '-' + o.id, innerNodes: i, outerNodes: o}
								links.push(l);
								// and the relationships
								i.related_nodes.push(o.id);
								i.related_links.push(l.id);
								o.related_nodes.push(i.id);
								o.related_links.push(l.id);
							});
							count = count + 1;
						}
					//}
			});
			data = {
				innerNodes: innerNodes,
				outerNodes: outerNodes.values(),
				links: links
			}
			// sort the data -- TODO: have multiple sort options
			outerNodes = data.outerNodes;
			data.outerNodes = Array(outerNodes.length);
			var i1 = 0;
			var i2 = outerNodes.length - 1;
			for (var i = 0; i < data.outerNodes.length; ++i)
			{
				if (i % 2 == 1)
					data.outerNodes[i2--] = outerNodes[i];
				else
					data.outerNodes[i1++] = outerNodes[i];
			}
			console.log(data.outerNodes.reduce(function(a,b) { return a + b.related_links.length; }, 0) / data.outerNodes.length);
			// from d3 colorbrewer:
			// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).
			var colors = ["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"]
			var color = d3.scale.linear()
					.domain([1, 97])
					.range([colors.length-1, 0])
					.clamp(true);
			var diameter = Math.min(window.innerWidth, window.innerHeight);
			var rect_width = 30;
			var rect_height = 14;
			var link_width = "1px";
			var il = data.innerNodes.length;
			var ol = data.outerNodes.length;
			var innerNodes_y = d3.scale.linear()
					.domain([0, il])
					.range([-(il * rect_height)/2, (il * rect_height)/2]);
			mid = (data.outerNodes.length/2.0)
			var outerNodes_x = d3.scale.linear()
					.domain([0, mid, mid, data.outerNodes.length])
					.range([15, 170, 190 ,355]);
			var outerNodes_y = d3.scale.linear()
					.domain([0, data.outerNodes.length])
					.range([0, diameter / 2 - 120]);
			// setup positioning
			data.outerNodes = data.outerNodes.map(function(d, i) {
				d.x = outerNodes_x(i);
				d.y = diameter/3;
				return d;
			});
			data.innerNodes = data.innerNodes.map(function(d, i) {
				d.x = -(rect_width / 2);
				d.y = innerNodes_y(i);
				return d;
			});
			function get_color(name)
			{
				var c = Math.round(color(name));
				if (isNaN(c))
					return '#dddddd';	// fallback color
				return colors[c];
			}
			// Can't just use d3.svg.diagonal because one edge is in normal space, the
			// other edge is in radial space. Since we can't just ask d3 to do projection
			// of a single point, do it ourselves the same way d3 would do it.
			function projectX(x)
			{
				return ((x - 90) / 180 * Math.PI) - (Math.PI/2);
			}
			var diagonal = d3.svg.diagonal()
					.source(function(d) { return {"x": d.outerNodes.y * Math.cos(projectX(d.outerNodes.x)),
						"y": -d.outerNodes.y * Math.sin(projectX(d.outerNodes.x))}; })
					.target(function(d) { return {"x": d.innerNodes.y + rect_height/2,
						"y": d.outerNodes.x > 180 ? d.innerNodes.x : d.innerNodes.x + rect_width}; })
					.projection(function(d) { return [d.y, d.x]; });
			var svg = d3.select("#Top20Rank").append("svg")
					.attr("width", diameter)
					.attr("height", diameter)
					.style("position", "absolute")
					.style("left", ((window.innerWidth/2)-(diameter/2))) 
					.append("g")
					.attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");
			// links
			var link = svg.append('g').attr('class', 'links').selectAll(".link")
					.data(data.links)
					.enter().append('path')
					.attr('class', 'link')
					.attr('id', function(d) { return d.id })
					.attr("d", diagonal)
					.attr('stroke', function(d) { return get_color(d.innerNodes.name); })
					.attr('stroke-width', link_width);
			// outerNodes nodes
			var onode = svg.append('g').selectAll(".outerNodes_node")
					.data(data.outerNodes)
					.enter().append("g")
					.attr("class", "outerNodes_node")
					.attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
					.on("mouseover", mouseover)
					.on("mouseout", mouseout);
			onode.append("circle")
					.attr('id', function(d) { return d.id })
					.attr("r", 4.5);
			onode.append("circle")
					.attr('r', 20)
					.attr('visibility', 'hidden');
			onode.append("text")
					.attr('id', function(d) { return d.id + '-txt'; })
					.attr("dy", ".31em")
					.attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
					.attr("transform", function(d) { return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)"; })
					.text(function(d) { return d.name; });
			// innerNodes nodes
			var inode = svg.append('g').selectAll(".innerNodes_node")
					.data(data.innerNodes)
					.enter().append("g")
					.attr("class", "innerNodes_node")
					.attr("transform", function(d, i) { return "translate(" + d.x + "," + d.y + ")"})
					.on("mouseover", mouseover)
					.on("mouseout", mouseout);
			inode.append('rect')
					.attr('width', rect_width)
					.attr('height', rect_height)
					.attr('id', function(d) { return d.id; })
					.attr('fill', function(d) { return get_color(d.name); });
			inode.append("text")
					.attr('id', function(d) { return d.id + '-txt'; })
					.attr('text-anchor', 'middle')
					.attr("transform", "translate(" + rect_width/2 + ", " + rect_height * .75 + ")")
					.text(function(d) { return d.name; });
			// need to specify x/y/etc
			d3.select(self.frameElement).style("height", diameter - 150 + "px");
			function mouseover(d)
			{
				// bring to front
				d3.selectAll('.links .link').sort(function(a, b){ return d.related_links.indexOf(a.id); });
				for (var i = 0; i < d.related_nodes.length; i++)
				{
					d3.select('#' + d.related_nodes[i]).classed('highlight', true);
					d3.select('#' + d.related_nodes[i] + '-txt').attr("font-weight", 'bold');
				}
				for (var i = 0; i < d.related_links.length; i++)
					d3.select('#' + d.related_links[i]).attr('stroke-width', '5px');
			}
			document.getElementById('top10Button').onclick = function() {
			}
			function mouseout(d)
			{
				for (var i = 0; i < d.related_nodes.length; i++)
				{
					d3.select('#' + d.related_nodes[i]).classed('highlight', false);
					d3.select('#' + d.related_nodes[i] + '-txt').attr("font-weight", 'normal');
				}
				for (var i = 0; i < d.related_links.length; i++)
					d3.select('#' + d.related_links[i]).attr('stroke-width', link_width);
			}

// ========================================================


				//clear checkbox input when program start
				document.getElementById("hispanicCheckBox").checked = false;
				document.getElementById("asianCheckBox").checked = false;
				document.getElementById("blackCheckBox").checked = false;
				document.getElementById("whiteCheckBox").checked = false;
				
				//store names that will be draw by bars() and pie()
				var selectedNames = [];
				//topArray: variables to store 2 top N (10, 20, 30) names
				var topHispanic = [];
				var topAsian = [];
				var topBlack = [];
				var topWhite = [];
				//parsing and searching from output file
				d3.csv("clean.csv", function(error, dataSet) {
					//type conversion (string to int);and search for top name
					dataSet.forEach(function(d) {
						d.BRTH_YR = +d.BRTH_YR;
						d.CNT = +d.CNT;
						d.RNK = +d.RNK;
						d.enabled = true;
						
						var maxRank = 40;//40 because that is the max that we will let user access
						
						//filering data base on ethnicity
						if("HISPANIC".localeCompare(d.ETHCTY) == 0 && d.RNK <= maxRank) {
							topHispanic.push(d);
						}
						else if("ASIAN AND PACIFIC ISLANDER".localeCompare(d.ETHCTY) == 0 && d.RNK <= maxRank) {
							topAsian.push(d);
						} 
						else if("BLACK NON HISPANIC".localeCompare(d.ETHCTY) == 0 && d.RNK <= maxRank) {
							topBlack.push(d);
						} 
						else if("WHITE NON HISPANIC".localeCompare(d.ETHCTY) == 0 && d.RNK <= maxRank) {
							topWhite.push(d);
						}
						else {
							console.log("Error: Data point have no matching ethicity or rank is not high enough");
						}
					});//end: type conversion; search for top name
				});//end: parsing and searching
			
				//combine "topArray" based on what option is checked in userInput
				function combineRace() {
					var selectedNames = [];
					if(document.getElementById("hispanicCheckBox").checked) {
						selectedNames = selectedNames.concat(topHispanic);
					}
					if(document.getElementById("asianCheckBox").checked) {
						selectedNames = selectedNames.concat(topAsian);
					}
					if(document.getElementById("blackCheckBox").checked) {
						selectedNames = selectedNames.concat(topBlack);
					}
					if(document.getElementById("whiteCheckBox").checked) {
						selectedNames = selectedNames.concat(topWhite);
					}
					return selectedNames;
				}//end: combineRace
				
				//Top 10 Button: update and draw "selectedNames" array when button is clicked.
				document.getElementById('top10Button').onclick = function() {
					//get names array base on user's seleted race
					selectedNames = combineRace();
					//sort names array base on CNT(count)
					selectedNames.sort(function(a,b) {
								return parseInt(b.CNT, 10) - parseInt(a.CNT, 10); 
							});
					console.log(selectedNames);//FOR DEBUGGING
					//Filter top 10 within names array
					selectedNames = topN(selectedNames, 10);
					console.log(selectedNames);//FOR DEBUGGING
					//draw barchart
					bars(selectedNames);
					//draw piechart
					pie(pieData(selectedNames));
				};//end: top 10 button
				
				//Top 20 Button: update and draw "selectedNames" array when button is clicked.
				document.getElementById('top20Button').onclick = function() {
					//get names array base on user's seleted race
					selectedNames = combineRace();
					//sort names array base on CNT(count)
					selectedNames.sort(function(a,b) {
								return parseInt(b.CNT, 10) - parseInt(a.CNT, 10); 
							});
					console.log(selectedNames);//FOR DEBUGGING
					//Filter top 10 within names array
					selectedNames = topN(selectedNames, 20);
					console.log(selectedNames);//FOR DEBUGGING
					//draw barchart
					bars(selectedNames);
					//draw piechart
					pie(pieData(selectedNames));
				};//end: top 20 button
				
				//Top 30 Button: update and draw "selectedNames" array when button is clicked.
				document.getElementById('top30Button').onclick = function() {
					//get names array base on user's seleted race
					selectedNames = combineRace();
					//sort names array base on CNT(count)
					selectedNames.sort(function(a,b) {
								return parseInt(b.CNT, 10) - parseInt(a.CNT, 10); 
							});
					//Filter top 10 within names array
					selectedNames = topN(selectedNames, 30);
					//draw barchart
					bars(selectedNames);
					//draw piechart
					pie(pieData(selectedNames));
				};//end: top 30 button
				
				//Top 40 Button: update and draw "selectedNames" array when button is clicked.
				document.getElementById('top40Button').onclick = function() {
					//get names array base on user's seleted race
					selectedNames = combineRace();
					//sort names array base on CNT(count)
					selectedNames.sort(function(a,b) {
								return parseInt(b.CNT, 10) - parseInt(a.CNT, 10); 
							});
					//Filter top 10 within names array
					selectedNames = topN(selectedNames, 40);
					//draw barchart
					bars(selectedNames);
					//draw piechart
					pie(pieData(selectedNames));
				};//end: top 40 botton
				
				//Filter function base on 'count' property of each name
				//param: array (that need to be filter), N (e.g. 10, 20 -> return top 10, top 20 names)
				function topN(nameArr, N) {
					var topArr = []; //store top names to return to caller
					
					//iterate thourgh all the name
					for(i = 0; i < nameArr.length; i++) {
						//topArr is !full(N elements) -> push to element
						if (i < N) {
							topArr.push(nameArr[i]);
						}
						//sort topArr base on name's element: CNT
						else if(topArr.length == N) { 
							topArr.sort(function(a,b) {
								return parseInt(b.CNT, 10) - parseInt(a.CNT, 10); 
							});
						}
						
						//topArr is full
						//-> compare new element to smallest topArr's element (last index)
						//-> if new element is larger, replace ir
						//-> re-sort
						//-> else, do nothing
						else {
							if(topArr[topArr.length - 1].CNT < nameArr[i].CNT) {
								//replace element
								topArr[topArr.length - 1] = nameArr[i];
								//re-sort
								topArr.sort(function(a,b) {
									return parseInt(b.CNT, 10) - parseInt(a.CNT, 10); 
								});
							}
							//else, do nothing
						}//end: if/else
					}
					return topArr;
				}//end: topN
				//Draw barchart
				function bars(data) {
					
					var w = 600;
					var h = 500;
					var padding = 100;
					//setup the svg
					var svg = d3.select("#svg-barchart")
						.attr("width", w+padding)
						.attr("height", h+padding);
						
					svg.append("svg:rect")
						.attr("width", "100%")
						.attr("height", "100%")
						.attr("stroke", "#000")
						.attr("fill", "none");
					svg.append("svg:g")
						.attr("id", "barchart")
						.attr("transform", "translate(50,50)");
						
					svg.append("svg:text")
						.attr("dy", ".35em")
						.attr("class", "barText");
					
					var padding = 40;// So we can see label at the right of the bar
					
					//max: the largest CNT within the array of Names
					max = d3.max(data, function(d) { return d.CNT; }) + padding;
					
					//set x scale
					x = d3.scale.linear()
						.domain([0, max])
						.range([0, w]);
					
					//set y scale
					y = d3.scale.ordinal()
						.domain(d3.range(data.length))
						.rangeBands([0, h], .2);
					
					var vis = d3.select("#barchart");
					
					var bars = vis.selectAll("rect.bar")
						.data(data);
					//enter
					bars.enter()
						.append("svg:rect")
						.attr("class", "bar")
						.attr("stroke", "#050");
					//exit 
					bars.exit()
					.transition()
					.duration(300)
					.ease("exp")
						.attr("width", 0)
						.remove();
					//Draw new bars
					bars
						.attr("stroke-width", 4)
						.transition()
						.duration(300)
						.ease("quad")
						.attr("width", function(d) { return x(d.CNT); })
						.attr("height", y.rangeBand())
						.attr("transform", function(d,i) {
							return "translate(" + [0, y(i)] + ")";
						})
						.attr("fill", function(d){
							return ethnicityColor(d.ETHCTY);
						});
					
					//remove all previous text
					var removeLable = d3.selectAll(".barText").remove();
					
					//var labels = vis.selectAll("g")
					var labels = vis.selectAll("text")
									.data(data);
									
					//enter
					labels.enter()
						.append("text")
						.attr("class", "barText")
						.attr("transform", function(d, i) { 
							return "translate(" + [0, y(i)] + ")"
						});
						
					//exit
					labels.exit().remove();
					
					//draw new labels
					labels
						.attr("x", function(d) { return x(d.CNT) + 3; })
						.attr("y", y.rangeBand()/2)
						.attr("dy", ".35em")
						.attr("font-size", 15)
						.attr("fill", function(d) {
							return genderColor(d.GNDR);
						})
						.text(function(d) { 
							return d.NM + " " + d.CNT; 
						});


					//function: return color to bar base on ethnicity
					function ethnicityColor(ethnicity) {
						if("HISPANIC".localeCompare(ethnicity) == 0) {
							return (HISPANIC_COLOR);
						}
						else if("ASIAN AND PACIFIC ISLANDER".localeCompare(ethnicity) == 0) {
							return (ASIAN_COLOR);
						} 
						else if("BLACK NON HISPANIC".localeCompare(ethnicity) == 0) {
							return (BLACK_COLOR);
						} 
						else if("WHITE NON HISPANIC".localeCompare(ethnicity) == 0 ) {
							return (WHITE_COLOR);
						}
					}//end: ethnicityColor
					
					//function: return color base on gender
					function genderColor(gender) {
						if("FEMALE".localeCompare(gender) == 0 ) {
							return (FEMALE_COLOR);						}
						else if("MALE".localeCompare(gender) == 0 ) {
							return (MALE_COLOR);
						}
					}//end: genderColor
				}
				
				//pieData: param: selectedNames array
				//			return: a 2-element array of {ethic name, total babies in the ethic}
				function pieData(data) {
					//var newData = [];
					var hispanicCount = 0, asianCount = 0, whiteCount = 0, blackCount = 0;
					
					//store ethic(label) and totalCount: sum of same ethic baby(count)
					data.forEach (function(d) {
						if("HISPANIC".localeCompare(d.ETHCTY) == 0) {
							hispanicCount += d.CNT;
						}
						else if("ASIAN AND PACIFIC ISLANDER".localeCompare(d.ETHCTY) == 0) {
							asianCount += d.CNT;
						} 
						else if("BLACK NON HISPANIC".localeCompare(d.ETHCTY) == 0) {
							blackCount += d.CNT;
						} 
						else if("WHITE NON HISPANIC".localeCompare(d.ETHCTY) == 0) {
							whiteCount += d.CNT;
						}
					  });
					  
					return newData = [
					  { label: 'Hispanic', count: hispanicCount }, 
					  { label: 'Asian', count: asianCount },
					  { label: 'Black', count: blackCount },
					  { label: 'White', count: whiteCount }
					];
				}//end: pieData
				
				//pie: param: returned array from pieData
				// 		Draw pie on page.
				function pie(data) {
				
					var width = 360;
					var height = 360;
					var radius = Math.min(width, height) / 2; //radius is calculated base on the mininum of "width" and "height"
					var color = [HISPANIC_COLOR,ASIAN_COLOR,BLACK_COLOR,WHITE_COLOR]; // HISPANIC, ASIAN, BLACK, WHITE
					
					var svg = d3.select("#svg-piechart")
								.attr("width",width)
								.attr("height", height)
								.append("g")
								.attr('transform', 'translate(' + (width / 2) + 
									',' + (height / 2) + ')');
					
					var arc = d3.svg.arc()
						.innerRadius(0)
						.outerRadius(radius);
					
					var pie = d3.layout.pie()
						.value(function(d) { return d.count; })
						.sort(null);
					  
					var tooltip = d3.select("body")
									.append("div")
									.style("position", "absolute")
									.style("z-index", "10")
									.style("visibility", "hidden")
									.style("background-color", "white");
									
				
					var path = svg.selectAll('path')
						.data(pie(data));
					
					//enter
					path
						.enter()
						.append('path')
						.attr('d', arc)
						.attr('fill', function(d, i) { 
						  return color[i]; 
						})                             
						.each(function(d) { this._current = d; });   
					
					//exit
					path.exit().remove();
					path.on('mouseover', function(d) {
						var total = d3.sum(data.map(function(d) {
						  return d.count;
						}));
						var percent = Math.round(1000 * d.data.count / total) / 10; 
						tooltip.style('visibility', 'visible');
						tooltip.text(d.data.label + " " + percent + "%" + "(" + d.data.count + ")");
					});
					  
					path.on('mouseout', function() {
						tooltip.style('visibility', 'hidden');
					});
					path.on("mousemove", function(){
						tooltip.style("top", (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");
					});
				}//end: pie

// ======================================
var INELASTIC_COEFFICIENT = 0.4;
var COLLISION_FACTOR = 0.1;
var DEFAULT_CIRCLE_PADDING_FACTOR = 6.0;
var MIN_RADIUS_FACTOR = 0.00003;
var MAX_RADIUS_FACTOR = 0.00006;
var STANDARD_FONT_SIZE = 9;
var FILLS = [
	['#827d92'],
	[FEMALE_COLOR, MALE_COLOR], // female, male
	[ ASIAN_COLOR, BLACK_COLOR, HISPANIC_COLOR, WHITE_COLOR ] // asian, black, hispanic, white
];

var redraw = function(cpf) { 
	d3.csv("clean.csv", function(error, data) {
	
		reset();
		
		init(data, window.innerWidth, window.innerHeight, cpf);
	
	}); // End xml callback.
}	
	
$(window).resize(redraw(DEFAULT_CIRCLE_PADDING_FACTOR));
$(document).ready(redraw(DEFAULT_CIRCLE_PADDING_FACTOR));
	
function reset() {
	var contentRoot = document.getElementById("content");
	while (contentRoot.firstChild) {
		contentRoot.removeChild(contentRoot.firstChild);
	}
}
	
function init(data, viewWidth, viewHeight, cpf) {
			
	var CIRCLE_PADDING_FACTOR = cpf;			
	
	// hacking
	var fill = d3.scale.ordinal().range(FILLS[0]);	
	var scaleSVG = d3.select('#content').append("svg");
	var scale = scaleSVG[0][0].currentScale;
	scaleSVG.remove();
	
    data = preProcessData(data, viewWidth, viewHeight, scale);	
	
	// gravity setup
	var gravitySVG = d3.select('#content').append("svg")
			.attr("width", "100%")
			.attr("height", "100%")
			.attr("id", "gravitySVG");
	
	var gravityRect = gravitySVG.node().getBoundingClientRect();
	
	var gravityEnter = drawGravity(data, gravitySVG, 2);
	
	// spiral setup
	var spiralSVG = d3.select("#content").append("svg")
			.attr("width", "100%")
			.attr("height", "100%")
			.attr("id", "spiralSVG");
			
	var spiralRect = spiralSVG.node().getBoundingClientRect();
	
	 spiralSVG = spiralSVG.append("g")
			.attr("transform", "translate(" + (spiralRect.width/2) + "," + (spiralRect.height/2) + ")");
			
	var spiralEnter = drawSpiral(data, spiralSVG, spiralRect.width, spiralRect.height, scale);
	

	$("#groupSelect").on("change", function() {
		draw($(this).val(), data, gravityEnter[0], gravitySVG, spiralRect.width, spiralRect.height, scale);
	});

	var colorVal = 0;
	$("#colorSelect").on("change", function() {
		colorVal = parseInt($(this).val());
		fill = d3.scale.ordinal().range(FILLS[colorVal]);	
		gravityEnter.selectAll("circle").style("fill", function (d) { return filler(d, colorVal, fill);  });
	});
	
	
	$("#scopeRange").on("change", function() {
 		redraw(($(this).val()));
	});
		
	$("#spimg").mouseenter(function() {
			sort(gravityEnter[0], spiralEnter);
	});

	$("#spimg").mouseleave(function() {
			draw("NONE", data, gravityEnter[0], gravitySVG, spiralRect.width, spiralRect.height, scale);
	});	
	
	

	var hq = [];
	
	function showAfterTimeout(e) {
		setTimeout(function() {
					e.show();
		},  200);
	}
	
	
	$("#drew").on("click", function() {
	
			$("#drew").hide();
			$("#sam").show();
			$("#arun").show();
			
			for (var i = 0; i < DROPPED_ELEMENTS.length; i++) {
				var c = DROPPED_ELEMENTS[i];
				var t = c.sibling;
				
				d3.select(c).attr("transform", "translate(0,0)");
				d3.select(t).attr("transform", "translate(0,0)");
				
			}
			
						d3.select(".chart").remove();
			DROPPED_ELEMENTS = [];
			NAMES = [];
			
		$(".expCtrl").each(function() {
			$(this).children().each(function() {
				showAfterTimeout($(this));
			});
		
			$(this).height(hq.shift());
		});
		
		$(".fades").each(function() {
			$(this).css("opacity", 1);
		});
		
		var lgnd = $("#legend");
		lgnd.css("left", 40);			
		lgnd.css("top", 40);
			
		$("#compare").width(0);
		$("#chart").hide();
		$("#Top20Rank").hide();
		
		var cs = gravityEnter.selectAll("circle");
		cs.style("opacity", 0);
		setTimeout(function() {
			$("#content").show();
			cs.transition().duration(1000).style("opacity", 1);
		}, 200);
	});
	
	$("#sam").on("click", function() {
			
			$("#sam").hide();
			$("#drew").show();
			$("#arun").show();
			
			
			var lgnd = $("#legend");
			
			$(".expCtrl").each(function() {
				$(this).children().each(function() {
					$(this).hide();
				});
				
				if ($(this).height() != 0) {
					hq.push($(this).height());
					$(this).height(0);
				}
			});
			
			$(".fades").each(function() {
				$(this).css("opacity", 0);
			});
			
			
			var w = window.innerWidth - (lgnd.width() + 40);
			var h = window.innerHeight - ($("#bttnDiv").height()  + 80); 
			
			lgnd.css("left", w);			
			lgnd.css("top", h);

			$("#compare").width(0);
			$("#content").hide();
			$("#chart").show();
			$("#Top20Rank").hide();
	});		
	
	$("#arun").on("click", function() {
	
			$("#arun").hide();
			$("#sam").show();
			$("#drew").show();

			$(".expCtrl").each(function() {
				$(this).children().each(function() {
					$(this).hide();
				});
				
				if ($(this).height() != 0) {
					hq.push($(this).height());
					$(this).height(0);
				}
			});
			
			$(".fades").each(function() {
				$(this).css("opacity", 0);
			});
			
			$("#compare").width(0);
			$("#chart").hide();			
			$("#content").hide();
			$("#Top20Rank").show();
	});		
	
	draw('NONE', data, gravityEnter[0], gravitySVG, spiralRect.width, spiralRect.height, scale);
	
	/*
	 * Begin Functions
	 */
	function preProcessData(data, viewWidth, viewHeight) {
		
			data = _.sortBy(data, function(node) { return parseInt(node.RNK) });
		
			var minRadius = Math.ceil(viewWidth*viewHeight*MIN_RADIUS_FACTOR);	
			var maxRadius = Math.floor(viewWidth*viewHeight*MAX_RADIUS_FACTOR);
			
			var currentScreenCapacity = 0;
			var totalScreenCapacity = (Math.pow(d3.min([viewWidth, viewHeight]), 2)) / (Math.pow(maxRadius, 2) * (scale*CIRCLE_PADDING_FACTOR));
	
			var minCnt = 1000;
			var maxCnt = -1;
			
			for (var i = 0; i < data.length; i++) {
				var d = data[i];
				if (currentScreenCapacity++ < totalScreenCapacity) {
					
					if (d.ETHCTY.indexOf("WHITE") >= 0) {
						d.ETHCTY = "WHITE";
					}
					else if (d.ETHCTY.indexOf("ASIAN") >= 0) {
						d.ETHCTY = "ASIAN";
					}
					else if (d.ETHCTY.indexOf("BLACK") >= 0) {
						d.ETHCTY = "BLACK";
					}
					
			
					// adding new properties
					d.NONE = "NONE";
					d.x = Math.random() * viewWidth;
					d.y = Math.random() * viewHeight;
				
					// update counts
					var cnt = parseInt(d.CNT);
					if (cnt > parseInt(maxCnt)) {
						maxCnt = cnt;
					}			
					if (cnt < parseInt(minCnt)) {
						minCnt = cnt;
					}
				}
				else {		
					data.splice(i,1);
					i--;
				}
			} // end for
		
			var radiusInputDomain = [minCnt, maxCnt];
			var radiusOutputRange = [minRadius, maxRadius];
			var circleRadiusScale = d3.scale.linear()
				.domain(radiusInputDomain)
				.range(radiusOutputRange);
			
			for (var j = 0; j < data.length; j++) {	
				data[j].radius = circleRadiusScale(parseInt(data[j].CNT));
			}
		
			return data;
		}
		
	function filler(d, fidx, fill) {
		console.log(fidx);
		switch (parseInt(fidx)) {
			case 0: return fill(0);
			case 1: return fill(d.GNDR);
			case 2: return fill(d.ETHCTY);
			default: console.log("ERROR");
		}
	}
	
	function drawGravity(data, svg, fidx) {
		
		var nodes = svg.selectAll("g").data(data);
		
		nodes.exit().remove();
		
		var gravityEnter = nodes.enter().append("g");
		
		var innerG = gravityEnter.append("g");
				
		var circles = innerG.append("circle")
			.attr("class", "node")
			.attr("r", 2)
			.style("fill", function (d) { return filler(d, fidx, fill);  });
		
		innerG.append("text")
			.attr("dx", parseInt(-25*scale))
			.attr("fill", "white")
			.attr("font-size", parseInt(STANDARD_FONT_SIZE * (1/(scale))))
			.text(function(d) { return d.NM; });
		
		circles.transition().duration(333)
			.attr("r", function(d) { return d.radius; })
			
		var drag = d3.behavior.drag()
			.on("dragstart", dragstarted)
			.on("drag", dragged)
			.on("dragend", dragended);
			
		innerG.call(drag);
		
		return gravityEnter;
	}
	
	function drawSpiral(data, svg, width, height, scale) {
	
		var numAxes = 8;
		var tickAxis = 1;
		var start = 0;
		var end = 0;
		if ( scale <= 0.25) {
			end = 5;
		}
		else if (scale < 1.0) {
			end = 4;
		}
		else if (scale < 1.75) {
			end = 3;
		}
		else if (scale <= 2.0) {
			end = 2;
		}
		else {
			end = 1;
		}
	
		var theta = function(r) {
			return -2*Math.PI*r;
		}
	
		var arc = d3.svg.arc()
			.startAngle(0)
			.endAngle(2*Math.PI);
		
		var radius = d3.scale.linear()
			.domain([start, end])
			.range([0, d3.min([width, height])/2 - 20]);
		
		var angle = d3.scale.linear()
			.domain([start, end])
			.range([0, 360])
	
		var pieces = d3.range(start, end+0.001, (end-start) / 1000);
	
		var spiral = d3.svg.line.radial()
			.interpolate("cardinal")
			.angle(theta)
			.radius(radius);
			
		var spiralEnter = svg.selectAll(".spiral")
				.data([pieces])
			.enter().append("path")
				.attr("class", "spiral")
				.attr("d", spiral);
	
		return spiralEnter
	}	
	
	function draw(varname, data, e, svg, width, height, scale) {
		
		d3.select(".spiral").style("opacity", "0");
		
		// return to parent positioning
		for (var i = 0; i < e.length; i++) {
			var innerG = e[i].getElementsByTagName("g")[0];
			innerG.style.transform = "translate(0px,0px)";
		}
			
		// begin gravity animation
		var force = d3.layout.force();
		var getCenters = function(vname, size) {
			var centers, map;
	
				// uniq - produce a duplicate free version of csv data
				// pluck - extracts a unique list of values for vname argument.
				// map - produce an object arrary with name and value
				centers = _.uniq(_.pluck(data, vname)).map(function (d) {
					return {name: d, value: 1};
				});
	
			map = d3.layout.pack().size(size);
	
			// Giving the map the unique nodes from the vname argument.
			map.nodes({children: centers});
	
			return centers;
		};
		var centers = getCenters(varname, [width, height]);
		force.on("tick", tick(data, centers, varname, e));
		labels(centers, svg, scale);
		force.start();
		// end gravity animation
	}
	
	function sort(list, spiralEnter) {
	
		gravitySVG.selectAll(".label").remove();
		d3.select(".spiral").transition().style("opacity", "1");
		
		list.sort(function(a, b) { 
			return parseInt(a.__data__.CNT) - parseInt(b.__data__.CNT); 
		});
		
		// ask path for length
		var spiralLength = spiralEnter.node().getTotalLength();
		var spiralPadding = spiralLength / list.length;
		for (var i = 0; i < list.length; i++) {
			console.log(list[i].__data__.CNT);
			
			var spiralPoint = spiralEnter.node().getPointAtLength(i * spiralPadding);
			var g = list[i];
			var gi = g.getElementsByTagName("g")[0];
			
			
			var trans = getCurrentTranslation(g);
			
			// target translation position relative to svg (0,0)
			var x2 = (viewWidth/2) + spiralPoint.x;
			var y2 = (viewHeight/2) + spiralPoint.y;
			
			// calculate the offset from g element's current translation
			var gidx = x2 - trans.x;
			var gidy = y2 - trans.y;
		
 			gi.style.transform = "translate(" + gidx + "px," + gidy + "px)";
		}
	}
	
	function getCurrentTranslation(g) {
		var transform = g.getAttribute("transform");
		var matches = transform.match(/-?\d+\.\d+/g);
			
		var p = {};
			// g element current translation
		p.x = matches[0];
		p.y = matches[1];
		
		return p;
	}
	
	/*
	 * Drag Functions
	 */
	
	// global last dragged position stack 
	var lastDragged = [];
	 	
	function dragstarted(d) {
		$("#compare").width("25%");
		d3.event.sourceEvent.stopPropagation();
		d3.select(this).classed("dragging", true);
	}
		
	function dragged(d) {
		
		// creat new point
		var p = {};
		p.x = d.x + d3.event.x;
		p.y = d.y + d3.event.y;
		
		// move object to point
		var innerG = d3.select(this);
		innerG.selectAll("*").attr("transform", "translate(" + d3.event.x + "," + d3.event.y + ")");
		
		// save point
		lastDragged.push(p);
	}
	
	function dragended(d) {

		// get and set object color
		var c = d3.select(this).select("circle").attr("style");
		d.color = c;
		
		// save names on chart
		NAMES.push(d);
		
		// add name to chart
		updateChart(NAMES);
		
		// get last position
		var lastPosition = lastDragged.pop();
		
		// reset saved drag positions for next drag
		lastDragged = [];
		
		var dropBox = d3.select("#compare").node().getBoundingClientRect();
		if (lastPosition.x >= dropBox.left && lastPosition.x <= dropBox.right
			&& lastPosition.y >= dropBox.top && lastPosition.y <= dropBox.bottom) {
			fall(d3.select(this), lastPosition, dropBox);
		}
		else {
			d3.select(this).selectAll("*").transition().duration(500).attr("transform", "translate(0,0)");
		}
	
		d3.select(this).classed("dragging", false);
	}
	

	/*
	 * Compare Panel Functions
	 */
	
	var NAMES = [];
	var DROPPED_ELEMENTS = [];
	var GRAVITY = 2.0;
	var FRAMES_PER_SECOND = 60;
			
	function updateChart(nms) {
			var compareBox = d3.select("#compare").node().getBoundingClientRect();
					
			var margin = { top: 40, right: 20, bottom: 30, left: 70},
			width = compareBox.width - margin.left - margin.right,
			height = (	compareBox.height*0.50) - margin.top - margin.bottom;
			
			var x = d3.scale.ordinal()
				.rangeRoundBands([0, height], 0.1);
				
			var y = d3.scale.linear()
				.range([0, width]);
				
			var xAxis = d3.svg.axis()
				.scale(x)
				.orient("left")
				.tickFormat(function(d) { return d.split(",")[0]; });
				
			var yAxis = d3.svg.axis()
				.scale(y)
				.orient("bottom")
				.tickValues([0, d3.max(data, function(d) { return parseInt(d.CNT); })])
				.tickFormat(function(d) { if (d == 0) return "min"; else return "max" }); 

			d3.select(".chart").remove();
					
			var chart = d3.select("#chartSpace").append("svg").attr("class", "chart")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");		
				
			x.domain(nms.map(function(d) { return d.NM + "," + d.ETHCTY + "," + d.GNDR; }));	
			
			y.domain([0, d3.max(data, function(d) { return parseInt(d.CNT); })]);
			
			var title = "Total Count by Name";
			
			chart.append("text")
				.attr("height", 30)
				.attr("font-size", "17px")
				.attr("fill", "white")
				.attr("dx", (width/2) - ((10*title.length)/2))
				.text(title);
				
			chart.append("g")
				.attr("class", "x axis")
				.call(xAxis);
				
			chart.append("g")
				.attr("class", "y axis")
				.attr("transform", "translate(0," + height + ")")
				.call(yAxis);
				
			var cd = chart.selectAll(".bar")
				.data(nms);
				
			cd.enter().append("rect")
				.attr("class", "bar")
				.attr("y", function(d) { return x(d.NM + "," + d.ETHCTY + "," + d.GNDR); })
				.attr("x", function(d) { return 0; })
				.attr("width", function(d) { return y(parseInt(d.CNT)); })
				.attr("height", x.rangeBand())
				.attr("style", function(d) { return d.color; });
			
			}

	function fall(g, lp, db) {
		
		var circle = g.selectAll("*")[0][0];
		var text = g.selectAll("*")[0][1];
		
		var env = {};
		env.left = db.left + window.scrollX;
		env.right = db.right + window.scrollX;
		env.bottom = db.bottom + window.scrollY;
		
		circle.absY = (circle.getBoundingClientRect().top + window.scrollY) + (circle.getBoundingClientRect().height/2);
		circle.absX = (circle.getBoundingClientRect().left + window.scrollX) + (circle.getBoundingClientRect().width/2);
		circle.radius = parseFloat(circle.getAttribute("r"));
		circle.dx = 0;
		circle.dy = 0;
		
		var frame = 0;
		for (var i = 0; i < DROPPED_ELEMENTS.length; i++) {
			var e = DROPPED_ELEMENTS[i];
			e.d = Math.sqrt(Math.pow(parseFloat(e.absX) - circle.absX, 2) + Math.pow(parseFloat(e.absY) - circle.absY, 2));
		}
		
		DROPPED_ELEMENTS.sort(function(a, b) { return a.d - b.d; });
	
		// only allow 3 second animations
		while (frame < (FRAMES_PER_SECOND * 3)) {
		
			applyForce(++frame, circle, text, env);
		
			if (atRest(circle, env)) break;			
		}
		
		circle.sibling = text;
		DROPPED_ELEMENTS.push(circle);
	}
	
	function atRest(circle, env) {
		var atVertex = 1.0 > Math.abs(env.bottom - (parseFloat(circle.absY) + circle.radius));
		var atRest = 1.0 > Math.sqrt((Math.pow(circle.dx, 2) + Math.pow(circle.dy, 2)));
		
		var isSupported = false;
		for (var i = 0; i < DROPPED_ELEMENTS.length; i++) {
			var other =  DROPPED_ELEMENTS[i];
			var dx = circle.absX - parseFloat(other.absX);
			var dy = circle.absY - parseFloat(other.absY)
			var distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
			if (distance <= (circle.radius + parseFloat(other.radius)) + 1.0) {
				isSupported = true;
			}
		}
			
		return (isSupported || atVertex) && atRest;
	}
	
	function applyForce(frame, circle, text, env) {
		if (DROPPED_ELEMENTS.length == 0) {
					collision(frame, circle, text, env, null); // applying gravity
		}	
		else {
			for (var i = 0; i < DROPPED_ELEMENTS.length; i++) {
				if (collision(frame, circle, text, env, DROPPED_ELEMENTS[i])) {
					return;
				}
			}
			
			// no collision with dropped elements
			collision(frame, circle, text, env, null); // applying gravity
		}
	}
	
	function collision(frame, circle, text, env, other) {
	
		if (env.left >= (parseFloat(circle.absX) - circle.radius)) {
		
			var dx = circle.dx *= ((-1.0) * INELASTIC_COEFFICIENT);
			var dy = circle.dy *= INELASTIC_COEFFICIENT; 
			
			var distanceToWall = env.left - (parseFloat(circle.absX) - circle.radius);
			if (distanceToWall > 0) {
				dx += distanceToWall;
			}
			
			animateCollision(frame, dx, dy, circle, text, env); 
			
			return true;
			
		} 
		else if (env.right <= (parseFloat(circle.absX) + circle.radius)) {
		
			var dx = circle.dx *= ((-1.0) * INELASTIC_COEFFICIENT);
			var dy = circle.dy *= INELASTIC_COEFFICIENT;

			var distanceToWall = env.right - (parseFloat(circle.absX) + circle.radius)
			if (distanceToWall < 0) {
				dx += distanceToWall;
			}
			
			animateCollision(frame, dx, dy, circle, text, env); 
			
			return true;
		}
		else if (parseFloat(env.bottom) <= (parseFloat(circle.absY) + circle.radius)) {
			 			
			var dx = circle.dx *= INELASTIC_COEFFICIENT;
			var dy = circle.dy *= (-1.0) * INELASTIC_COEFFICIENT;
			
			var distanceToFloor = env.bottom - (parseFloat(circle.absY) + circle.radius)
			if (distanceToFloor < 0) {
				dy += distanceToFloor;
			}
			
			animateCollision(frame, dx, dy, circle, text, env); 
			
			return true;
		}
		else if (other != null) {
			
			var speed = Math.sqrt(Math.pow(circle.dx, 2) + Math.pow(circle.dy, 2));

			var dx, dy;
			var xmag = parseFloat(circle.absX) - other.absX;
			var ymag = parseFloat(circle.absY) - other.absY;
			var distance = Math.sqrt(Math.pow(xmag, 2) + Math.pow(ymag, 2));		
			if (distance <= (parseFloat(circle.radius) + other.radius)) {
				if (ymag != 0.0) {
					var theta = Math.atan(xmag/ymag);
					dx = circle.dx = speed * INELASTIC_COEFFICIENT * Math.sin(theta) * -1.0;
					dy = circle.dy = speed * INELASTIC_COEFFICIENT * Math.cos(theta) * -1.0;
					
					var mag = (parseFloat(circle.radius) + other.radius) - distance;
					
 					dx += (parseFloat(mag)*Math.sin(theta) * -1.0);
 					dy += (parseFloat(mag)*Math.cos(theta) * -1.0);
					
				}
				else {
					dx = circle.dx = INELASTIC_COEFFICIENT * circle.dx * 1.0; // symmetry
					dy = circle.dy = 0.0;
				}
				
				animateCollision(frame, dx , dy, circle, text, env); 
				
				return true;
			}
			else {
				return false;
			}
		}
		else {
		
			var dx, dy;
			dx = circle.dx = parseFloat(circle.dx); // symmetry
			dy = circle.dy += parseFloat(GRAVITY);
						
			animateCollision(frame, dx, dy, circle, text, env); 
			
			return true;
		}
	}
		
	function animateCollision(frame, dx, dy, circle, text, env) {

		circle.absX += parseFloat(dx);
		circle.absY += parseFloat(dy);
			
		setTimeout(function() {
			var current = getCurrentTranslation(circle);
			var x = parseFloat(current.x) + dx;
			var y = parseFloat(current.y) + dy;			
			circle.setAttribute("transform", "translate(" + x + "," + y + ")");
			text.setAttribute("transform", "translate(" + x + "," + y + ")");
		}, frame * FRAMES_PER_SECOND);
	}	
	
	// end force functions
	
	function tick(data, centers, varname) {
		var foci = {}; // Used for quick look-up
		for (var i = 0; i < centers.length; i++) {
			foci[centers[i].name] = centers[i];
		}
		
		return function(e) {
			for (var i = 0; i < data.length; i++) {
				var o = data[i];
				var f = foci[o[varname]];
				o.y += (f.y - o.y) * e.alpha;
				o.x += (f.x - o.x) * e.alpha;
			}
			
		   gravityEnter.each(collide(COLLISION_FACTOR, data))
				.attr("transform", function (d) { return "translate(" + d.x + ", " + d.y + ")"; });
		}
	};
	
	function labels(centers, gravitySVG, scale) {
	
		var gravitySVG = d3.select("#gravitySVG");
		
		gravitySVG.selectAll(".label").remove();
		
		gravitySVG.selectAll(".label")
			.data(centers).enter().append("text")
			.attr("class", "label")
			.text(function (d) { console.log(d.name); if (d.name != "NONE") return d.name; else return ""; })
			.attr("fill", "black")
			.style("font-size", 30 / scale)
			.attr("transform", function (d) {
				if (d.name == "NONE") return "";
				else return "translate(" + (d.x - ((d.name.length)*3)) + ", " + (d.y - d.r + (50 / scale)) + ")";
			});
	}
	
	function collide(alpha, data) {
		var maxRadius = d3.max(_.pluck(data, 'radius'));
		var padding = 4;
		var quadtree = d3.geom.quadtree(data);
		return function(d) {
			var r = d.radius + maxRadius + padding,
				nx1 = d.x - r,
				nx2 = d.x + r,
				ny1 = d.y - r,
				ny2 = d.y + r;
			quadtree.visit(function(quad, x1, y1, x2, y2) {
				if (quad.point && (quad.point !== d)) {
					var x = d.x - quad.point.x,
						y = d.y - quad.point.y,
						l = Math.sqrt(x * x + y * y),
						r = d.radius + quad.point.radius + padding;
					if (l < r) {
						l = (l - r) / l * alpha;
						d.x -= x *= l;
						d.y -= y *= l;
						quad.point.x += x;
						quad.point.y += y;
					}
				}
				
				return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
			});
		}
	} // Source: http://bl.ocks.org/mbostock/1748247
	
} // end init
</script>
</body>
</html>