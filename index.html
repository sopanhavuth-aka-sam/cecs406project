<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title> NYC Baby Names</title>
	<style>
	
	
	#legend {
	position:absolute;
	top:40px;
	left:20px;
	width:200px;
	z-index:99999;
	border:1px solid black;
	}
	
	.plabel {
		width:45%;
		text-align: right;
		padding-right:5%;
		display:inline-block;
	}
	
	#rangeDiv, #sortDiv {
		width:80%;
		margin:auto;
		text-align:center;
	}
		
		
	#spimg {
		width: 60px;
		display:block;
		margin: 20px auto;
	}
	
	.bar {
		fill: steelblue;
	}
	
	.axis text {
		font: 10px sans-serif;
		fill: white;
	}
	
	.axis path,
	.axis line {
		fill: none;
		stroke: white;
		shape-rendering: crispEdges;
	}
	
	.x.axis path {
		display:none;
	}
	
		body {
			margin:40px;
		}
		
		#boxout {
			width:100%;
			height:100%;
		}
		
		#box {
			width:100%;
			height:100%;
			z-index:1000;
		}
		
		#container {
			width:100%;
			float:left;
		}
		
		#content {
			position: absolute;
			top:0px;
			left:0px;
			width:100%;
			height:100%;
		}
		
		#compare {
		position:absolute;
			top:0px;
			right:0;
			width:0%;
			height:100%;
			background-color: black;
			transition: width 500ms ease;
		}
		
		#compTab {
			margin: 10px;
			font-size: 24px;
			color: white;
			border: 1px solid yellow;
			z-index:1000;
			width: 100%;
			height: auto;
		}

		
		td {
			padding: 5px;
			border-bottom: 1px solid black;
		}
		
		td.update {
			color: white;
		}
		
		td.enter {
			color:green;
		}
		
		td.exit, tr.exit td {
			color: red;
		}
		
		td.row-header {
			border-right:1px solid black;
			font-weight: bold;
		}
		
		svg {
			margin:auto;
		}
		
		#gravitySVG {
			position:absolute;
			top:0;
			left:0;
			z-index: 1;
	
		}
		
		#spiralSVG {
			position:absolute;
			top:0;
			left:0;
			z-index: -1;
		}
		
		.axis path {
			fill: none;
			stroke: #999;
			stroke-dasharray: 2 3;
		}
		
		g, circle {
			transition: transform 650ms ease;
		}
		
		circle.tick {
			fill: #f3f3f3;
			stroke: #999;
			stroke-dasharray:2 3;
		}
		
		path.spiral {
			fill:none;
			stroke: black;
			stroke-width: 2px;
			opacity:0;
		}
		</style>
	</head>
<body>
<div id="legend">
	<div>
		<p class="plabel">Group By:</p>
		<select id="groupSelect">
			<option value="NONE">None</option>		
			<option value="GNDR">Gender</option>
			<option value="ETHCTY">Ethnicity</option>
		</select>
		</div>
	<div>
		<p class="plabel">Color By:</p>
		<select id="colorSelect">
			<option value="0">None</option>		
			<option value="1">Gender</option>
			<option value="2">Ethnicity</option>
		</select>
	</div>
	<div id="rangeDiv">
		<p>Scope:</p>
		<input id="scopeRange" value="7.5" type="range" min="1.0" max="15.0" step="1.0">
	</div>
	<div id="sortDiv">
		<p>Sort:</p>
		<img id="spimg" src="spiral.png">
	</div>
</div>
<div id="container">
	<div id="content"></div>
	<div id="compare">
		<div id="chartSpace"></div>
		<svg id="boxout"><g id="box"></svg>
	</div>
</div>
<script src="node_modules/gravitybox/gravitybox.js"></script>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="node_modules/jquery/dist/jquery.js"></script>
<script src="node_modules/underscore/underscore.js"></script>
<script>

var INELASTIC_COEFFICIENT = 0.4;
var COLLISION_FACTOR = 0.1;
var DEFAULT_CIRCLE_PADDING_FACTOR = 6.0;
var MIN_RADIUS_FACTOR = 0.00003;
var MAX_RADIUS_FACTOR = 0.00006;
var STANDARD_FONT_SIZE = 9;
var FILLS = [
	['#827d92'],
	['#86AFF2','#EE8482'], // female, male
	['#827d92','#827354','#523536','#72856a']
];

var redraw = function(cpf) { 
	d3.csv("clean.csv", function(error, data) {
	
		reset();
		
		init(data, window.innerWidth, window.innerHeight, cpf);
	
	}); // End xml callback.
}	
	
$(window).resize(redraw(DEFAULT_CIRCLE_PADDING_FACTOR));
$(document).ready(redraw(DEFAULT_CIRCLE_PADDING_FACTOR));
	
function reset() {
	var contentRoot = document.getElementById("content");
	while (contentRoot.firstChild) {
		contentRoot.removeChild(contentRoot.firstChild);
	}
}
	
function init(data, viewWidth, viewHeight, cpf) {
			
		var CIRCLE_PADDING_FACTOR = cpf;
			var NAMES = [];
		
			
		function updateChart(nms) {
			var compareBox = d3.select("#compare").node().getBoundingClientRect();
					
			var margin = { top: 40, right: 20, bottom: 30, left: 70},
			width = compareBox.width - margin.left - margin.right,
			height = (	compareBox.height*0.50) - margin.top - margin.bottom;
			
			var x = d3.scale.ordinal()
				.rangeRoundBands([0, height], 0.1);
				
			var y = d3.scale.linear()
				.range([0, width]);
				
			var xAxis = d3.svg.axis()
				.scale(x)
				.orient("left")
				.tickFormat(function(d) { return d.split(",")[0]; });
				
			var yAxis = d3.svg.axis()
				.scale(y)
				.orient("bottom")
				.tickValues([0, d3.max(data, function(d) { return parseInt(d.CNT); })])
				.tickFormat(function(d) { if (d == 0) return "min"; else return "max" }); 

			d3.select(".chart").remove();
					
			var chart = d3.select("#chartSpace").append("svg").attr("class", "chart")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");		
				
			x.domain(nms.map(function(d) { return d.NM + "," + d.ETHCTY + "," + d.GNDR; }));	
			
			y.domain([0, d3.max(data, function(d) { return parseInt(d.CNT); })]);
			
			var title = "Total Count by Name";
			
			chart.append("text")
				.attr("height", 30)
				.attr("font-size", "17px")
				.attr("fill", "white")
				.attr("dx", (width/2) - ((10*title.length)/2))
				.text(title);
				
			chart.append("g")
				.attr("class", "x axis")
				.call(xAxis);
				
			chart.append("g")
				.attr("class", "y axis")
				.attr("transform", "translate(0," + height + ")")
				.call(yAxis);
				
			var cd = chart.selectAll(".bar")
				.data(nms);
				
			cd.enter().append("rect")
				.attr("class", "bar")
				.attr("y", function(d) { return x(d.NM + "," + d.ETHCTY + "," + d.GNDR); })
				.attr("x", function(d) { return 0; })
				.attr("width", function(d) { return y(parseInt(d.CNT)); })
				.attr("height", x.rangeBand())
				.attr("style", function(d) { return d.color; });
			
			}
			
					
			
			/*
			 * end chart
			 */
			 
			 
			 
	// hacking
	var fill = d3.scale.ordinal().range(FILLS[0]);	
	var scaleSVG = d3.select('#content').append("svg");
	var scale = scaleSVG[0][0].currentScale;
	scaleSVG.remove();
	
    data = preProcessData(data, viewWidth, viewHeight, scale);	
	
	// gravity setup
	var gravitySVG = d3.select('#content').append("svg")
			.attr("width", "100%")
			.attr("height", "100%")
			.attr("id", "gravitySVG");
	
	var gravityRect = gravitySVG.node().getBoundingClientRect();
	
	var gravityEnter = drawGravity(data, gravitySVG, 2);
	
	// spiral setup
	var spiralSVG = d3.select("#content").append("svg")
			.attr("width", "100%")
			.attr("height", "100%")
			.attr("id", "spiralSVG");
			
	var spiralRect = spiralSVG.node().getBoundingClientRect();
	
	 spiralSVG = spiralSVG.append("g")
			.attr("transform", "translate(" + (spiralRect.width/2) + "," + (spiralRect.height/2) + ")");
			
	var spiralEnter = drawSpiral(data, spiralSVG, spiralRect.width, spiralRect.height, scale);
	

	$("#groupSelect").on("change", function() {
		draw($(this).val(), data, gravityEnter[0], gravitySVG, spiralRect.width, spiralRect.height, scale);
	});

	var colorVal = 0;
	$("#colorSelect").on("change", function() {
		colorVal = parseInt($(this).val());
		fill = d3.scale.ordinal().range(FILLS[colorVal]);	
		gravityEnter.selectAll("circle").style("fill", function (d) { return filler(d, colorVal, fill);  });
	});
	
	
	$("#scopeRange").on("change", function() {
 		redraw(($(this).val()));
	});
		
	$("#spimg").mouseenter(function() {
			sort(gravityEnter[0], spiralEnter);
	});

	$("#spimg").mouseleave(function() {
			draw("NONE", data, gravityEnter[0], gravitySVG, spiralRect.width, spiralRect.height, scale);
	});	
	draw('NONE', data, gravityEnter[0], gravitySVG, spiralRect.width, spiralRect.height, scale);
	
	/*
	 * Begin Functions
	 */
	function preProcessData(data, viewWidth, viewHeight) {
		
			data = _.sortBy(data, function(node) { return parseInt(node.RNK) });
		
			var minRadius = Math.ceil(viewWidth*viewHeight*MIN_RADIUS_FACTOR);	
			var maxRadius = Math.floor(viewWidth*viewHeight*MAX_RADIUS_FACTOR);
			
			var currentScreenCapacity = 0;
			var totalScreenCapacity = (Math.pow(d3.min([viewWidth, viewHeight]), 2)) / (Math.pow(maxRadius, 2) * (scale*CIRCLE_PADDING_FACTOR));
	
			var minCnt = 1000;
			var maxCnt = -1;
			
			for (var i = 0; i < data.length; i++) {
				var d = data[i];
				if (currentScreenCapacity++ < totalScreenCapacity) {
			
					// adding new properties
					d.NONE = "NONE";
					d.x = Math.random() * viewWidth;
					d.y = Math.random() * viewHeight;
				
					// update counts
					var cnt = parseInt(d.CNT);
					if (cnt > parseInt(maxCnt)) {
						maxCnt = cnt;
					}			
					if (cnt < parseInt(minCnt)) {
						minCnt = cnt;
					}
				}
				else {		
					data.splice(i,1);
					i--;
				}
			} // end for
		
			var radiusInputDomain = [minCnt, maxCnt];
			var radiusOutputRange = [minRadius, maxRadius];
			var circleRadiusScale = d3.scale.linear()
				.domain(radiusInputDomain)
				.range(radiusOutputRange);
			
			for (var j = 0; j < data.length; j++) {	
				data[j].radius = circleRadiusScale(parseInt(data[j].CNT));
			}
		
			return data;
		}
		
	function filler(d, fidx, fill) {
		console.log(fidx);
		switch (parseInt(fidx)) {
			case 0: return fill(0);
			case 1: return fill(d.GNDR);
			case 2: return fill(d.ETHCTY);
			default: console.log("ERROR");
		}
	}
	
	function drawGravity(data, svg, fidx) {
		
		var nodes = svg.selectAll("g").data(data);
	
		nodes.exit().remove();
		
		var gravityEnter = nodes.enter().append("g");
		
			
		var drag = d3.behavior.drag()
			.on("dragstart", dragstarted)
			.on("drag", dragged)
			.on("dragend", dragended);

		var innerG = gravityEnter.append("g");
				
		var circles = innerG.append("circle")
			.attr("class", "node")
			.attr("r", 2)
			.style("fill", function (d) { return filler(d, fidx, fill);  });
				
		circles.transition().duration(333)
			.attr("r", function(d) { return d.radius; })
		
		innerG.append("text")
			.attr("dx", parseInt(-25*scale))
			.attr("fill", "white")
			.attr("font-size", parseInt(STANDARD_FONT_SIZE * (1/(scale))))
			.text(function(d) { return d.NM; });
		
		innerG.call(drag);
		
		return gravityEnter;
	}
	
	function drawSpiral(data, svg, width, height, scale) {
	
		var numAxes = 8;
		var tickAxis = 1;
		var start = 0;
		var end = 0;
		if ( scale <= 0.25) {
			end = 5;
		}
		else if (scale < 1.0) {
			end = 4;
		}
		else if (scale < 1.75) {
			end = 3;
		}
		else if (scale <= 2.0) {
			end = 2;
		}
		else {
			end = 1;
		}
	
		var theta = function(r) {
			return -2*Math.PI*r;
		}
	
		var arc = d3.svg.arc()
			.startAngle(0)
			.endAngle(2*Math.PI);
		
		var radius = d3.scale.linear()
			.domain([start, end])
			.range([0, d3.min([width, height])/2 - 20]);
		
		var angle = d3.scale.linear()
			.domain([start, end])
			.range([0, 360])
	
		var pieces = d3.range(start, end+0.001, (end-start) / 1000);
	
		var spiral = d3.svg.line.radial()
			.interpolate("cardinal")
			.angle(theta)
			.radius(radius);
			
		var spiralEnter = svg.selectAll(".spiral")
				.data([pieces])
			.enter().append("path")
				.attr("class", "spiral")
				.attr("d", spiral);
	
		return spiralEnter
	}	
	
	function draw(varname, data, e, svg, width, height, scale) {
		
		d3.select(".spiral").style("opacity", "0");
		
		// return to parent positioning
		for (var i = 0; i < e.length; i++) {
			var innerG = e[i].getElementsByTagName("g")[0];
			innerG.style.transform = "translate(0px,0px)";
		}
			
		// begin gravity animation
		var force = d3.layout.force();
		var getCenters = function(vname, size) {
			var centers, map;
	
				// uniq - produce a duplicate free version of csv data
				// pluck - extracts a unique list of values for vname argument.
				// map - produce an object arrary with name and value
				centers = _.uniq(_.pluck(data, vname)).map(function (d) {
					return {name: d, value: 1};
				});
	
			map = d3.layout.pack().size(size);
	
			// Giving the map the unique nodes from the vname argument.
			map.nodes({children: centers});
	
			return centers;
		};
		var centers = getCenters(varname, [width, height]);
		force.on("tick", tick(data, centers, varname, e));
		labels(centers, svg, scale);
		force.start();
		// end gravity animation
	}
	
	function sort(list, spiralEnter) {
	
				gravitySVG.selectAll(".label").remove();
		d3.select(".spiral").transition().style("opacity", "1");
		
		list.sort(function(a, b) { 
			return parseInt(a.__data__.CNT) - parseInt(b.__data__.CNT); 
		});
		
		


		// ask path for length
		var spiralLength = spiralEnter.node().getTotalLength();
		var spiralPadding = spiralLength / list.length;
		for (var i = 0; i < list.length; i++) {
			console.log(list[i].__data__.CNT);
			
			var spiralPoint = spiralEnter.node().getPointAtLength(i * spiralPadding);
			var g = list[i];
			var gi = g.getElementsByTagName("g")[0];
// 			var text = g.getElementsByTagName("text")[0];
			
			
			var trans = getCurrentTranslation(g);
			
			// target translation position relative to svg (0,0)
			var x2 = (viewWidth/2) + spiralPoint.x;
			var y2 = (viewHeight/2) + spiralPoint.y;
			
			// calculate the offset from g element's current translation
			var gidx = x2 - trans.x;
			var gidy = y2 - trans.y;
		
 			gi.style.transform = "translate(" + gidx + "px," + gidy + "px)";
		}
	}
	
	function getCurrentTranslation(g) {
		var transform = g.getAttribute("transform");
		var matches = transform.match(/-?\d+\.\d+/g);
			
		var p = {};
			// g element current translation
		p.x = matches[0];
		p.y = matches[1];
		
		return p;
	}
	
	
	// drag functions
	
	function dragstarted(d) {
		$("#compare").width("25%");
		d3.event.sourceEvent.stopPropagation();
		d3.select(this).classed("dragging", true);
	}
		
	var lastDragged = [];
	function dragged(d) {
		
		var p = {};
		p.x = d.x + d3.event.x;
		p.y = d.y + d3.event.y;
		
		var innerG = d3.select(this);
		innerG.selectAll("*").attr("transform", "translate(" + d3.event.x + "," + d3.event.y + ")");
		
		lastDragged.push(p);
	}
	
	function dragended(d) {


		var c = d3.select(this).select("circle").attr("style");
		
		d.color = c;
		NAMES.push(d);
		updateChart(NAMES);
			
// 		var tableModel = addToTableModel(d);
// 		update(tableModel);
		
		var dropBox = d3.select("#compare").node().getBoundingClientRect();
		
		var lastPosition = lastDragged.pop(); // get last position
		lastDragged = [];
		
		if (lastPosition.x >= dropBox.left && lastPosition.x <= dropBox.right
			&& lastPosition.y >= dropBox.top && lastPosition.y <= dropBox.bottom) {
			
			var g = d3.select(this);
			
			fall(g, lastPosition, dropBox);
			
			
		}
		else {
			d3.select(this).selectAll("*").transition().duration(500).attr("transform", "translate(0,0)");
		}
	
		d3.select(this).classed("dragging", false);
	}
	
	/*
	 * Table logic
	 */

	var NAMES = [];
	// end drag functions
	
	// force functions
	
	var DROPPED_ELEMENTS = [];
	var GRAVITY = 2.0;
	var FRAMES_PER_SECOND = 60;
	function fall(g, lp, db) {
		
		var circle = g.selectAll("*")[0][0];
		var text = g.selectAll("*")[0][1];
		
		var env = {};
		env.left = db.left + window.scrollX;
		env.right = db.right + window.scrollX;
		env.bottom = db.bottom + window.scrollY;
		
		circle.absY = (circle.getBoundingClientRect().top + window.scrollY) + (circle.getBoundingClientRect().height/2);
		circle.absX = (circle.getBoundingClientRect().left + window.scrollX) + (circle.getBoundingClientRect().width/2);
		circle.radius = parseFloat(circle.getAttribute("r"));
		circle.dx = 0;
		circle.dy = 0;
		
		var frame = 0;
		for (var i = 0; i < DROPPED_ELEMENTS.length; i++) {
			var e = DROPPED_ELEMENTS[i];
			e.d = Math.sqrt(Math.pow(parseFloat(e.absX) - circle.absX, 2) + Math.pow(parseFloat(e.absY) - circle.absY, 2));
		}
		
		DROPPED_ELEMENTS.sort(function(a, b) { return a.d - b.d; });
	
		// only allow 3 second animations
		while (frame < (FRAMES_PER_SECOND * 3)) {
		
			applyForce(++frame, circle, text, env);
		
			if (atRest(circle, env)) break;			
		}
		
		DROPPED_ELEMENTS.push(circle);
	}
	
	function atRest(circle, env) {
		var atVertex = 1.0 > Math.abs(env.bottom - (parseFloat(circle.absY) + circle.radius));
		var atRest = 1.0 > Math.sqrt((Math.pow(circle.dx, 2) + Math.pow(circle.dy, 2)));
		
		var isSupported = false;
		for (var i = 0; i < DROPPED_ELEMENTS.length; i++) {
			var other =  DROPPED_ELEMENTS[i];
			var dx = circle.absX - parseFloat(other.absX);
			var dy = circle.absY - parseFloat(other.absY)
			var distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
			if (distance <= (circle.radius + parseFloat(other.radius)) + 1.0) {
				isSupported = true;
			}
		}
			
		return (isSupported || atVertex) && atRest;
	}
	
	function applyForce(frame, circle, text, env) {
		if (DROPPED_ELEMENTS.length == 0) {
					collision(frame, circle, text, env, null); // applying gravity
		}	
		else {
			for (var i = 0; i < DROPPED_ELEMENTS.length; i++) {
				if (collision(frame, circle, text, env, DROPPED_ELEMENTS[i])) {
					return;
				}
			}
			
			// no collision with dropped elements
			collision(frame, circle, text, env, null); // applying gravity
		}
	}
	
	function collision(frame, circle, text, env, other) {
	
		if (env.left >= (parseFloat(circle.absX) - circle.radius)) {
		
			var dx = circle.dx *= ((-1.0) * INELASTIC_COEFFICIENT);
			var dy = circle.dy *= INELASTIC_COEFFICIENT; 
			
			var distanceToWall = env.left - (parseFloat(circle.absX) - circle.radius);
			if (distanceToWall > 0) {
				dx += distanceToWall;
			}
			
			animateCollision(frame, dx, dy, circle, text, env); 
			
			return true;
			
		} 
		else if (env.right <= (parseFloat(circle.absX) + circle.radius)) {
		
			var dx = circle.dx *= ((-1.0) * INELASTIC_COEFFICIENT);
			var dy = circle.dy *= INELASTIC_COEFFICIENT;

			var distanceToWall = env.right - (parseFloat(circle.absX) + circle.radius)
			if (distanceToWall < 0) {
				dx += distanceToWall;
			}
			
			animateCollision(frame, dx, dy, circle, text, env); 
			
			return true;
		}
		else if (parseFloat(env.bottom) <= (parseFloat(circle.absY) + circle.radius)) {
			 			
			var dx = circle.dx *= INELASTIC_COEFFICIENT;
			var dy = circle.dy *= (-1.0) * INELASTIC_COEFFICIENT;
			
			var distanceToFloor = env.bottom - (parseFloat(circle.absY) + circle.radius)
			if (distanceToFloor < 0) {
				dy += distanceToFloor;
			}
			
			animateCollision(frame, dx, dy, circle, text, env); 
			
			return true;
		}
		else if (other != null) {
			
			var speed = Math.sqrt(Math.pow(circle.dx, 2) + Math.pow(circle.dy, 2));

			var dx, dy;
			var xmag = parseFloat(circle.absX) - other.absX;
			var ymag = parseFloat(circle.absY) - other.absY;
			var distance = Math.sqrt(Math.pow(xmag, 2) + Math.pow(ymag, 2));		
			if (distance <= (parseFloat(circle.radius) + other.radius)) {
							// debugger;
				if (ymag != 0.0) {
					var theta = Math.atan(xmag/ymag);
					dx = circle.dx = speed * INELASTIC_COEFFICIENT * Math.sin(theta) * -1.0;
					dy = circle.dy = speed * INELASTIC_COEFFICIENT * Math.cos(theta) * -1.0;
					
					var mag = (parseFloat(circle.radius) + other.radius) - distance;
					
 					dx += (parseFloat(mag)*Math.sin(theta) * -1.0);
 					dy += (parseFloat(mag)*Math.cos(theta) * -1.0);
					
				}
				else {
					dx = circle.dx = INELASTIC_COEFFICIENT * circle.dx * 1.0; // symmetry
					dy = circle.dy = 0.0;
				}
				
				animateCollision(frame, dx , dy, circle, text, env); 
				
				return true;
			}
			else {
				return false;
			}
		}
		else {
		
			var dx, dy;
			dx = circle.dx = parseFloat(circle.dx); // symmetry
			dy = circle.dy += parseFloat(GRAVITY);
						
			animateCollision(frame, dx, dy, circle, text, env); 
			
			return true;
		}
	}
		
	function animateCollision(frame, dx, dy, circle, text, env) {

		circle.absX += parseFloat(dx);
		circle.absY += parseFloat(dy);
			
		setTimeout(function() {
			var current = getCurrentTranslation(circle);
			var x = parseFloat(current.x) + dx;
			var y = parseFloat(current.y) + dy;			
			circle.setAttribute("transform", "translate(" + x + "," + y + ")");
			text.setAttribute("transform", "translate(" + x + "," + y + ")");
		}, frame * FRAMES_PER_SECOND);
	}	
	
	// end force functions
	
	function tick(data, centers, varname) {
		var foci = {}; // Used for quick look-up
		for (var i = 0; i < centers.length; i++) {
			foci[centers[i].name] = centers[i];
		}
		
		return function(e) {
			for (var i = 0; i < data.length; i++) {
				var o = data[i];
				var f = foci[o[varname]];
				o.y += (f.y - o.y) * e.alpha;
				o.x += (f.x - o.x) * e.alpha;
			}
			
		   gravityEnter.each(collide(COLLISION_FACTOR, data))
				.attr("transform", function (d) { return "translate(" + d.x + ", " + d.y + ")"; });
		}
	};
	
	function labels(centers, gravitySVG, scale) {
	
		var gravitySVG = d3.select("#gravitySVG");
		
		gravitySVG.selectAll(".label").remove();
		
		gravitySVG.selectAll(".label")
			.data(centers).enter().append("text")
			.attr("class", "label")
			.text(function (d) { console.log(d.name); if (d.name != "NONE") return d.name; else return ""; })
			.attr("fill", "black")
			.style("font-size", 30 / scale)
			.attr("transform", function (d) {
				if (d.name == "NONE") return "";
				else return "translate(" + (d.x - ((d.name.length)*3)) + ", " + (d.y - d.r + (50 / scale)) + ")";
			});
	}
	
	function collide(alpha, data) {
		var maxRadius = d3.max(_.pluck(data, 'radius'));
		var padding = 4;
		var quadtree = d3.geom.quadtree(data);
		return function(d) {
			var r = d.radius + maxRadius + padding,
				nx1 = d.x - r,
				nx2 = d.x + r,
				ny1 = d.y - r,
				ny2 = d.y + r;
			quadtree.visit(function(quad, x1, y1, x2, y2) {
				if (quad.point && (quad.point !== d)) {
					var x = d.x - quad.point.x,
						y = d.y - quad.point.y,
						l = Math.sqrt(x * x + y * y),
						r = d.radius + quad.point.radius + padding;
					if (l < r) {
						l = (l - r) / l * alpha;
						d.x -= x *= l;
						d.y -= y *= l;
						quad.point.x += x;
						quad.point.y += y;
					}
				}
				
				return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
			});
		}
	} // Source: http://bl.ocks.org/mbostock/1748247
	
} // end init
</script>
</body>
</html>