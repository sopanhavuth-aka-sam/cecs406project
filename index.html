<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title> NYC Baby Names</title>
	<style>
		body {
			margin:40px;
		}
		
		#content {
			width:100%;
			margin:auto;
		}
		
		svg {
			margin:auto;
		}
		
		#c1b {
			position:absolute;
			top:80px;
			left:0;
	
		}
		
		#c1a {
			position:absolute;
			top:80px;
			left:0;
		}
		
		.axis path {
			fill: none;
			stroke: #999;
			stroke-dasharray: 2 3;
		}
		
		g, circle {
			transition: transform 500ms ease;
		}
		
		circle.tick {
			fill: #f3f3f3;
			stroke: #999;
			stroke-dasharray:2 3;
		}
		
		path.spiral {
			fill:none;
			stroke: black;
			stroke-width: 2px;
			opacity:0;
		}
		</style>
	</head>
<body>
<div>
	<button class="btn" id="all">All</button>
	<button class="btn" id="ETHCTY">Ethnicity</button>
	<button class="btn" id="GNDR">Gender</button>
	<button class="btn" id="SORT">Sort</button>
</div>
<div id="content"></div>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="node_modules/jquery/dist/jquery.js"></script>
<script src="node_modules/underscore/underscore.js"></script>
<script>
d3.csv("data_full.csv", function(error, data) {
	
	var CIRCLE_PADDING_FACTOR = 7.0;
	
	var maxCnt = -1;
	var minCnt = 1000;

	var viewWidth = window.innerWidth;
	var viewHeight = window.innerHeight;
	
	var MIN_CIRCLE_RADIUS = Math.ceil(viewWidth*viewHeight*0.00002);	
	var MAX_CIRCLE_RADIUS = Math.floor(viewWidth*viewHeight*0.000045);

	var spiralEnter = drawSpiral();
	
	//     var fill = d3.scale.ordinal().range(['#827d92','#827354','#523536','#72856a'])
	var fill = d3.scale.category10();

	
	var svg = d3.select('#content').append("svg")
		.attr("width", viewWidth)
		.attr("height", viewHeight)
		.attr("id", "c1b");
			
	
    data = _.sortBy(data, function(node) { return parseInt(node.RNK) });
    
    
    var capacity = 0;
    var totalCapacity = (viewWidth * viewHeight) / (Math.pow(MAX_CIRCLE_RADIUS, 2) * CIRCLE_PADDING_FACTOR);
    
   
    console.log("total cap " + totalCapacity);
	// selecting data
	for (var j = 0; j < data.length; j++) {
	
		if (capacity++ < totalCapacity) {
			data[j].all = "ALL";
			
			var cnt = parseInt(data[j].CNT);
			if (cnt > maxCnt) {
				maxCnt = cnt;
			}
			
			if (cnt < minCnt) {
				minCnt = cnt;
			}
			
			// Assigning random positions to allow nodes to fly in at start.
			data[j].x = Math.random() * viewWidth;
			data[j].y = Math.random() * viewHeight;
		}
		else {		
			data.splice(j,1);
			j--;
			continue;
		}
	} // end for
	
	var circleRadiusScale = d3.scale.linear().domain([minCnt, maxCnt]).range([MIN_CIRCLE_RADIUS, MAX_CIRCLE_RADIUS]);
	for (var j = 0; j < data.length; j++) {	
		data[j].radius = circleRadiusScale(data[j].CNT);
	}	
	
		
	var padding = 4;
	var maxRadius = d3.max(_.pluck(data, 'radius'));
	
	var getCenters = function(vname, size) {
		var centers, map;
		
			// uniq - produce a duplicate free version of csv data
			// pluck - extracts a unique list of values for vname argument.
			// map - produce an object arrary with name and value
			centers = _.uniq(_.pluck(data, vname)).map(function (d) {
				return {name: d, value: 1};
			});
		
		map = d3.layout.pack().size(size);
		
		// Giving the map the unique nodes from the vname argument.
		map.nodes({children: centers});
		
		return centers;
	};
	
	var nodes = svg.selectAll("g").data(data);
	
	var gs = nodes.enter().append("g");
		
	var gsi = gs.append("g");
	
	var circles = gsi.append("circle")
		.attr("class", "node")
		.attr("r", 2)
		.style("fill", function (d) { return fill(d.ETHCTY);  });

	circles.transition().duration(500)
		.attr("r", function(d) { return d.radius; });
		
		gsi.append("text")
		.attr("dx", "-30")
		.attr("fill", "white")
		.attr("font-size", "9")
		.text(function(d) { return d.NM; });
	var force = d3.layout.force();
	
		// Page loads with ethnicity button selected.
	draw('GNDR', gs[0]);
	
	$(".btn").click(function() {
		switch(this.id) {
			case "all":
			case "GNDR":
			case "ETHCTY":
				draw(this.id, gs[0]);
				break;
			case "SORT":
				sort(gs[0]);
				break;
			default:
				console.log("DEFAULT!");
			}
	});
	
	
	function drawSpiral() {
	
	var numAxes = 8;
	var tickAxis = 1;
	var start = 0;
	var end = 4;
	
	var theta = function(r) {
		return -2*Math.PI*r;
	}
	
	var arc = d3.svg.arc()
		.startAngle(0)
		.endAngle(2*Math.PI);
		
	var radius = d3.scale.linear()
		.domain([start, end])
		.range([0, d3.min([viewWidth, viewHeight])/2 - 20]);
		
	var angle = d3.scale.linear()
		.domain([start, end])
		.range([0, 360])
		
	var halfwide = viewWidth/2;
	var halftall = viewHeight/2;
	
	var svg = d3.select("#content").append("svg")
		.attr("width", viewWidth)
		.attr("height", viewHeight)
		.attr("id", "c1a")
	.append("g")
		.attr("transform", "translate(" + halfwide + "," + halftall + ")");
		
	var pieces = d3.range(start, end+0.001, (end-start) / 1000);
	
	var spiral = d3.svg.line.radial()
		.interpolate("cardinal")
		.angle(theta)
		.radius(radius);
			
	var spiralEnter = svg.selectAll(".spiral")
			.data([pieces])
		.enter().append("path")
			.attr("class", "spiral")
			.attr("d", spiral);
	// 		.attr("transform", function (d) { return "rotate(" + 90 + ")" });
	
	return spiralEnter
	}
		
	function draw(varname, gs) {
		
		d3.select(".spiral").style("opacity", "0");
		// return to parent positioning
		for (var i = 0; i < gs.length; i++) {
			var childg = gs[i].getElementsByTagName("g")[0];
			childg.style.transform = "translate(0px,0px)";
		}
			
		// begin gravity animation
		var centers = getCenters(varname, [viewWidth, viewHeight]);
		force.on("tick", tick(centers, varname));
		labels(centers);
		force.start();
	}
	
	function sort(list) {
	
		d3.select(".spiral").transition().style("opacity", "1");
	
		// ask path for length
		var spiralLength = spiralEnter.node().getTotalLength();
		var spiralPadding = spiralLength / list.length;
		for (var i = 0; i < list.length; i++) {
			var spiralPoint = spiralEnter.node().getPointAtLength(i * spiralPadding);
			var g = list[i];
			var gi = g.getElementsByTagName("g")[0];
// 			var text = g.getElementsByTagName("text")[0];
			
			var transform = g.getAttribute("transform");
			var matches = transform.match(/\d*\.\d*/g);
			
			// g element current translation
			var x1 = matches[0];
			var y1 = matches[1];
			
			// target translation position relative to svg (0,0)
			var x2 = (viewWidth/2) + spiralPoint.x;
			var y2 = (viewHeight/2) + spiralPoint.y;
			
			// calculate the offset from g element's current translation
			var gidx = x2 - x1;
			var gidy = y2 - y1;
		
 			gi.style.transform = "translate(" + gidx + "px," + gidy + "px)";
		}
	}
	
	/*
	 * Factory type function that returns a function set up by its parameters.
	 */
	function tick(centers, varname) {
		var foci = {}; // Used for quick look-up
		for (var i = 0; i < centers.length; i++) {
			foci[centers[i].name] = centers[i];
		}
		
		return function(e) {
			for (var i = 0; i < data.length; i++) {
				var o = data[i];
				var f = foci[o[varname]];
				o.y += (f.y - o.y) * e.alpha;
				o.x += (f.x - o.x) * e.alpha;
			}
			
			gs.each(collide(.25))
				.attr("transform", function (d) { return "translate(" + d.x + ", " + d.y + ")"; });
		}
	};
	
	/*
	 * Passing in the centers array to determine where to place labels.
	 */
	function labels (centers) {
		svg.selectAll(".label").remove();
		
		svg.selectAll(".label")
			.data(centers).enter().append("text")
			.attr("class", "label")
			.text(function (d) { return d.name })
			.attr("fill", "black")
			.attr("transform", function (d) {
				return "translate(" + (d.x - ((d.name.length)*3)) + ", " + (d.y - d.r + 20) + ")";
			});
	}
	
	// Resolves collisions between d and all other circles.
	// Source: http://bl.ocks.org/mbostock/1748247
	function collide(alpha) {
		var quadtree = d3.geom.quadtree(data);
		return function(d) {
			var r = d.radius + maxRadius + padding,
				nx1 = d.x - r,
				nx2 = d.x + r,
				ny1 = d.y - r,
				ny2 = d.y + r;
			quadtree.visit(function(quad, x1, y1, x2, y2) {
				if (quad.point && (quad.point !== d)) {
					var x = d.x - quad.point.x,
						y = d.y - quad.point.y,
						l = Math.sqrt(x * x + y * y),
						r = d.radius + quad.point.radius + padding;
					if (l < r) {
						l = (l - r) / l * alpha;
						d.x -= x *= l;
						d.y -= y *= l;
						quad.point.x += x;
						quad.point.y += y;
					}
				}
				
				return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
			});
		}
	}
	
}); // End xml callback.
	
</script>
</body>
</html>